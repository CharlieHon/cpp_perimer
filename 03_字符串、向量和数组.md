标准库中最重的类型：`string`和 `vector`。`string`表示可变长的字符序列，`vector`存放的是某种给定类型对象的可变长序列。

## 3.1 命名空间的 using 声明

目前为止，用到的库函数基本上都属于命名空间 `std`，而程序也显式地将这一点标示了出来。例如，`std::cin`表示从标准输入中读取内容。此处使用作用域操作符 `::`的含义是：**编译器应从操作符左侧名字所示的作用域中寻找右侧那个名字**。

有了 `using`声明就无须专门的前准也能使用所需的名字。`using`声明具有如下的形式：`using namespace::name;`一旦声明如左语句，就可以直接访问命名空间中的名字。

**每个名字都需要独立的 `using`声明**

按照规定，每个 `using`声明引入命名空间中的一个成员。C++语言的形式比较自由，因此既可以一行只放一条using语句声明，也可以一行放多条。不过要注意，**用到的每个名字都必须又自己的声明语句，而且每句话都得以分号结束**。

```cpp
#include <iostream>
using std::cin;
using std::cout; using std::endl;

int main()
{
    cout << "Enter two number:" << endl;
    int v1, v2;
    cin >> v1 >> v2;
    cout << "The sum of " << v1 << " and "
        << " is " << v1+v2 << endl;

    return 0;
}
```

**头文件不应包含using声明**

**因为头文件的内容会拷贝到所有引用它的文件中去，如果头文件里有某个using声明，那么每个使用头文件的文件就都会有这个声明，可能会引起名字冲突**。

## 3.2 标准库类型 string

标准库类型 `string`表示可变长序列，使用string类型必须首先包含string头文件。

```cpp
#include <string>
using std::string;
```

### 3.2.1 定义和初始化string对象

如何初始化类的对象是有类本身决定的。一个类可以定义很多种初始化对象的方式，只不过这些方式之间必须有所区别：**或者是初始值的数量不同，或者是初始值的类型不同**。

```cpp
string s1;      // 默认初始化，s1是一个空字符串
string s2 = s1; // 拷贝初始化，s2是s1的副本
string s3 = "hiya"; // s3是该字符串字面值的副本
string s4(10, 'h'); //直接初始化，s4的内容是hhhhhhhhhh
```

**如果提供了一个字符串字面值，则该字面值中除了最后那个空字符之外其他所有的字符都被拷贝到新建的string对象中去**。如果提供的是一个数字和字符，则string对象的内容是给定字符连续重复若干次后得到的序列。

初始化 string 对象的方式

```cpp
string s1;		//默认初始化，s1是一个空串
string s2(s1);		//s2是s1的符本
string s2 = s1;		//与上等价
string s3("value");	//s3是字面值"value"的副本，除了字面值最后的那个空字符外
string s3 = "value";	//与上等价
string s4(n, 'x');	//把s4初始化为由连续n个字符x组成的串
```

**直接初始化和拷贝初始化**

```cpp
// 直接初始化和拷贝初始化
// 如果使用等号(=)初始化一个变量，实际上执行的是拷贝初始化
// 编译器把等号右侧的初始值拷贝到新建的对象中去
string s5 = "hiya";
//如果不适用等号，则执行的是直接初始化
string s6("hiya");
string s7(10, 'c');
```

### 3.2.2 string对象上的操作

一个类除了要规定初始化对象的方式外，还要定义对象上所能执行的操作。

```cpp
// 读string对象
string s;
//在执行读取操作时，string会自动忽略开头的空白(即空格符、换行符、制表符等)
//并从第一个真正的字符开始读起，知道遇到下一处空白为止
cin >> s;   // 将string对象读入s，遇到空白停止

// 读取未知数量的string对象
string word;
while(cin >> word){         // 反复读取，直到到达文件末尾EOF
    cout << word << endl;
}
```

**使用 `getline`读取一整行**

有时希望在最终得到的字符串中**保留输入时的空白符**。

`getline`函数的参数是一个输入流和一个string对象，函数从给定的输入流中读取内容，直到遇到换行符为止(换行符也被读进来了)，然后所读的内容存入到那个string对象中去(注意**不存换行符**)。`getline`只要一遇到换行符就结束读取操作并返回结果，哪怕输入的一开始就是换行符也是如此，此时得到空串。

```cpp
//使用getline读取一整行
string line;
//每次读入一整行，直到达到文件末尾
while(getline(cin, line)){
    cout << line << endl;
}
```

> 触发getline函数返回的那个换行符实际上被丢弃了，得到的string对象并不包含该换行符。

**string 的 empty 和 size 操作**

- `empty`函数根据string对象是否为空返回一个对应的布尔值
- `size`函数返回string对象的长度，即对象中字符的个数。

```cpp
// string 的 empty 和 size 操作
//每次读入一行整数，遇到空行直接跳过
while(getline(cin, line)){
    if(!line.empty())       // 如果非空
        cout << line << endl;
}
// 每次读入一整行，输出其中超过80个字符的行
while(getline(cin, line)){
    if(line.size() > 80)
        cout << line << endl;
}
```

`string::size_type`类型

string类及其他大多数标准库类型都定义了几种配套的类型。`size`函数返回的是一个 `string::size_type`类型的值。**它是一个无符号类型的值而且能够存放下任何string对象的大小**。

```cpp
//string::size_type类型
//可以通过auto或者decltype推断变量类型
// string::size_type len = s.size();
auto len = s.size();
```

比较字符串

相等性运算符(`==`和 `!=`)分别检验两个string对象相等或不相等，string对象相等意味着它们的长度相同而且所包含的字符也全部相同。

1. 如果两个string对象的长度不同，而且较短string对象的每个字符都与较长string对象对应位置上的字符相同，就说较短string对象小于较长string对象。
2. 如果两个string对象在某些对应的位置上不一致，则string对象比较的结果其实是string对象中第一对相异字符比较结果。

**两个 `string`对象相加**

两个 `string`对象相加得到一个新的string对象，其内容是把左侧的运算对象与右侧的运算对象串接而成。复合运算符 `+=`负责把右侧string对象的内容追加到左侧string对象的后面。

```cpp
// 两个string对象相加
string a = "hello", b = "world\n";
string c = a + b;
a += b;     // 等价于 a = a + b
```

**字面值和string对象相加**

因为标准库允许把**字符字面值**和**字符串字面值**转换成string对象，所以在需要string对象的地方就可以使用这两种字面值来代替。

```cpp
//字面值和string对象
string s1("hiya");
string s2 = s1 + ", ";
// string s3 = "hello" + ", world";    //错误：两个对象都不是string
string s4 = s2 + ", " + "TiKi";
//等价于 string s4 = (s2 + ", ") + "TiKi";  // ()括号内运算结果是string对象
// string s5 = "hello" + ", world" + s1;   //错误，运算从左到右进行
```

> 因为某些历史原因，也为了与C兼容，所以C++语言中的字符串字面值并不是标准库类型string的对象。切记，**字符串字面值与string对象是不同的类型。**

## 术语表
