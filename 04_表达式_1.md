# 第4章 表达式

表达式(expression)由一个或多个运算对象(operand)组成，对表达式求值将得到一个结果(result)。字面值和变量是最简单的表达式，其结果就是字面值和变量的值。

## 4.1 基础

### 4.1.1 基础概念

C++定义了一元运算符(unary operator)和二元运算符(binary operator)。

- 一元运算符：作用于一个运算对象的运算符，如取地址(`&`)和解引用(`*`)；
- 二元运算符：作用于两个运算对象，如相等运算符(`==`)和乘法运算符(`*`)
- 三元运算符：只有一个作用于三个对象，条件运算符(`cond ? expr1 : expr2`)

#### 运算对象转换

小整数类型(如 `bool`,`char`,`short`等)通常被提升(promoted)成较大的整数类型，主要是 `int`。

#### 重载运算符

使用重载运算符时，其包括运算对象的类型和返回值的类型，都是由该运算符定义的；但是**运算对象的个数、运算符的优先级和结合律都是无法改变**。

#### 左值和右值

C++的表达式要不然是右值(`rvalue`)，要不然就是左值(`lvalue`)。

> 当一个对象被用作右值的时候，用的是对象的**值(内容**)；
>
> 当对象被用作左值的时候，用的是对象的**身份(在内存中的位置)**。

在需要右值的地方可以用左值来代替，但是不能把右值当成左值(也就是位置)使用。当一个左值被当成右值使用时，实际使用的它的内容(值)。

- 赋值运算符需要一个(非常量)左值作为其左侧运算对象，得到的结果仍然是一个左值
- 取地址运算符作用于一个左值运算对象，返回一个指向该运算对象的指针，这个指针是一个右值。
- 内置解引用运算符、下标运算符、迭代器解引用运算符、string和vector的下标运算符的求值结果都是左值。
- 内置类型和迭代器的递增递减运算符作用于左值运算对象，其前置版本所得结果也是左值。

> 使用关键字 `decltype`的时候，左值和右值也有所不同。如果表达式的求值结果是左值，`decltype`作用于该表达式(不是变量)得到一个**引用类型**。

```cpp
int x = 12;
int *p = &x;
decltype(*p) y = x;	// y的类型是 int&
decltype(&p) pp = &p;	// pp的类型是 int**

```

### 4.1.2 优先级和结合律

表达式中的括号无视优先级规则，可以使用括号将表达式的某个局部括起来使其得到优先计算。

如果优先级相同，则其组合规则由结合律确定。

算术运算符满足左结合律，意味着如果运算符的优先级相同，将按照从左向右的顺序组合运算对象。

```cpp
// 优先级和结合律
int ia[] = {0,2,4,6,8};
int last = *(ia+4); // 等价于 int last = ia[4]
last = *ia + 4; // last = ia[0] + 4

// IO相关的运算符满足左结合律，可以把几个IO运算对象结合在一条表达式当中
int v1, v2;
cin >> v1 >> v2;
```

### 4.1.3 求值顺序

优先级规定了运算对象的组合方式，但是没有说明对象按照什么顺序求值。在大多数情况下，不会明确指定求值的顺序。对于如下的表达式，我们知道 `f1`和 `f2`一定会在执行乘法之前被调用，但是无法知道到底f1在f2之前调用还是之后。

```cpp
int i = f1() * f2();
```

> 对于那么没有指定执行顺序的运算符来说，如果表达式指向并修改了同一个对象，将会引发错误并产生未定义的行为。

```cpp
// 求值顺序
int i = 0;
cout << i << " " << ++i << endl;    // 未定义，无论编译器是否报错，该段代码都是错误的
```

**有4中运算符明确规定了运算对象的求值顺序：**

1. 逻辑与(`&&`)运算符，它规定先求左侧运算对象的值，只有当左侧运算对象的值为**真**时才继续求右侧运算对象的值。
2. 逻辑或(`||`)运算符，它规定先求左侧运算对象的值，只有当左侧运算对象的值为**假**时才继续求右侧运算对象的值。
3. 条件运算符(`?:`)，
4. 逗号运算符(`,`)，

#### 求值顺序、优先级、结合律

```cpp
// 求值顺序、优先级、结合律
int x = f()+ g()*h()+j();
// 优先级规定，g()的返回值和h()的返回值相乘
// 结合律规定，f()的返回值先与g()和h()的乘积相加，所得结果再与j()的返回值相加
// 求值顺序：对于这些函数的调用顺序没有明确规定
```

> 建议：处理复合表达式
>
> 1. 拿不准的时候最好用括号来强制让表达式的组合关系符合程序逻辑的要求。
> 2. 如果改变了某个运算对象的值，在表达式的其他地方不要再使用这个运算对象(有例外)。

## 4.2 算术运算符

| 算术运算符 | 左结合律 |
| ---------- | -------- |
| `+`      | 一元正号 |
| `-`      | 一元负号 |
| `*`      | 乘法     |
| `/`      | 除法     |
| `%`      | 求余     |
| `+`      | 加法     |
| `-`      | 减法     |

```cpp
// 算术运算符的运算对象和求值结果都是右值
// 在表达式求值之前，小整数的运算对象被提升成较大的整数类型，所有运算对象最终会转换成同一类型。
bool b = true;
// 布尔变量b的值为真，参与运算时将被提升成整数值1，对它求负后的结果是-1
// 将-1再转换回布尔值并将其作为b2的初始值
bool b2 = -b;   // b2是true
```

> 提示：溢出和其他算术运算异常
>
> 算术表达式有可能产生未定义的结果。一部分原因是数学性质本身：例如除数是0的情况；另外一部分则源于计算机的特点：例如溢出，当计算的结果超出该类型所能表示的范围时就会产生溢出。

```cpp
// 溢出
short short_value = 32767;  // 如果short类型占16位，则能表示的最大值是32767
short_value += 1;   // 该计算导致溢出
// 该值发生了“环绕”，符号位本来是0，由于溢出被改成了1，于是结果变成一个负值
cout << "short_value: " << short_value << endl; // -32768

// C++11新标准规定商一律向0取整(即直接切除小数部分)
int ival1 = 21/6;
int ival2 = -21/6;
cout << "21/6 = " << ival1 << " ival2 = " << ival2 << endl;

// 在除法运算中，如果两个对象的符号相同则商为正，否则商为负
// 除了-m导致溢出的特殊情况外，其他时候(-m)/n和m/(-n)都等于-(m/n)

// 运算符%俗称“取余”，负责计算两个整数相除所得的余数，参与取余运算的运算对象必须是整数类型
// 如果 m%n 不等于0，则它的符号和 m 相同
// m%(-n) 等于 m%n; (-m)%n等于-(m%n)
cout << 21%6 << endl;   // 3
cout << -21%-8 << endl; // -5
cout << 21%-5 << endl;  // 1
cout << 21/6 << endl;   // 3
cout << -21/-8 << endl; // 2
cout << 21/-5 << endl;  // -4
```

## 4.3 逻辑和关系运算符

关系运算符作用于算术类型或指针类型，逻辑运算符作用于任意能转换成布尔值的类型。逻辑运算符和关系运算符的返回值都是布尔类型。值为0的运算对象表示假，否则表示真。对于这两类运算符来说，运算对象和求值结果都是右值。

| 结合律 | 逻辑运算符和关系运算符 | 功能     |
| ------ | ---------------------- | -------- |
| 右     | `!`,    `!expr` | 逻辑非   |
| 左     | `<`                  | 小于     |
| 左     | `<=`                 | 小于等于 |
| 左     | `>`                  | 大于     |
| 左     | `>=`                 | 大于等于 |
| 左     | `==`                 | 相等     |
| 左     | `!=`                 | 不相等   |
| 左     | `&&`                 | 逻辑与   |
| 左     | `\\`                 | 逻辑或   |

> 逻辑运算符的优先级低于关系运算符

```cpp
// 逻辑运算符的优先级低于关系运算符
string s("hello world");
size_t index = 0;
// 首先检查index是否到达string对象的末尾，然后再判断是否是空格
// 等价于(index != s.size()) && (!isspace(s[index]))
while(index != s.size() && !isspace(s[index])){
    s[index] = toupper(s[index]);
    ++index;
}
cout << s << endl;

// 在遇到空字符或者以句号结束的字符串时进行换行，否则用空格隔开
// vector<string> vs{10,"a"};  // 花括号{}可以转换成()，反之不可
vector<string> vs{"hello","world","","I","love","China."};
for(const auto &text : vs){
    cout << text;
    if(text.empty() || text[text.size()-1]=='.')
        cout << endl;
    else
        cout << " ";
}
```

```cpp
// 逻辑非运算符(!)
// 将运算对象的值取反后返回
vector<int> vi1;
if(!vi1.empty())    cout << vi1[0] << endl;
else    cout << "vi1 is empty!" << endl;

// 关系运算符
// 因为关系运算符的求值结果是布尔值，所以将几个关系运算符连写在一起回产生意想不到的结果
int i = 1, j = 3, k = 2;
// 等价于(i<j)<k，将i<j的结果true/false与k比较
if(i < j < k)   cout << "if(i<j<k) is true" << endl;
else    cout << "if(i<j<k) is false" << endl;

// 正确逻辑关系
if(i<j && j<k)  cout << "i<j<k" << endl;
else    cout << "not i<j<k" << endl;

// 相等性测试与布尔字面值
int x = 1, *p = 0;
if(x)   cout << "x是任意非0值" << endl;
if(!p)  cout << "p是空指针" << endl;
```












## 结束
