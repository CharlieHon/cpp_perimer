## 2.1 基本内置类型

C++定义了一套包括**算术类型**和**空类型**在内的基本数据类型。其中**算术类型包含了字符、整数型、布尔值和浮点数**。**空类型不对应具体的值，仅用于一些特殊的场合**。

### 2.1.1 算术类型

算数类型分为：整型（integral type，包括字符和布尔类型在内）和浮点型。

布尔类型（bool）的取值是真(true)或者假(false)。

基本的字符类型是 `char`，一个 `char`的空间应确保可以存放机器基本字符集中任意字符对应的数字值。也就是说，一个 `char`的大小和一个机器字节一样。

> C++语言规定：
>
> sizeof(short) ≤ sizeof(int)≤ sizeof(long)≤ sizeof(long long)

> **内置类型的机器实现**
>
> 计算机以比特序列存储数据，每个比特非0即1。
>
> 大多数计算机以2的整数次幂个比特作为块来处理内存，可寻址的最小内存块称为“字节(byte)”，存储的基本单元称为“字(word)”，通常由几个字节组成。
>
> 大多数计算机将内存中的每个字节与一个数字（被称为“地址(address)”）关联起来。
>
> 为了赋予内存中某个地址明确的含义，必须首先知道存储在该地址的数据的类型。类型决定了数据所占的比特数以及该如何解释这些比特的内容。

浮点型可表示单精度、双精度和扩展精度值。通常，`float`以1个字（32比特）来表示，`double`以2个字（64比特）来表示。一般来说，类型 `float`和 `double`分别有7和16个有效位。

**带符号类型和无符号类型**

除去布尔型和扩展的字符型之外，其他整型可以划分为**带符号**(signed)的和**无符号**(unsigned)的两种。带符号类型可以表示正数、负数和0，无符号类型则仅能表示大于等于0的值。类型 `unsigned int`可以缩写为 `unsigned`。

无符号类型中所有比特都用来存储值。

> - 执行浮点数运算选用 `double`，因为 `float`通常精度不够而且双精度浮点数和单精度浮点数的计算代价相差无几。

### 2.1.2 类型转换

当在程序的某处我们使用了一种类型而其实对象应该取另一种类型时，程序会自动进行类型转换(convert)。

```cpp
#include <iostream>

int main()
{
    // 把一个非布尔类型的算术值赋给布尔类型时，初始值为0则结果为false，否则结果为true
    bool b = 42;        // b为真(true)
    int i = b;          // i = 1
    // 把浮点数赋给整数类型时，进行了近似处理。结果值将仅保留浮点数中小数点之前的部分
    i = 3.14;           // i = 3
    // 把整数赋给浮点数时，小数部分记为0.
    double pi = i;      // pi = 3.0
    // 当赋给无符号类型一个超出它表示范围的值时，结果是
    // 初始值对无符号类型表示数值总数取模后的余数。256 - 1 = 255 
    unsigned char c = -1;   // c = 255
    // 当赋给带符号类型一个超过它表示范围的值时，结果是未定义的(undefined)
    signed char c2 = 256;   //假设char占8比特，c2值是未定义的

    return 0;
}
```

- 含有无符号类型的表达式

当一个表达式中既有无符号又有 `int`值时，那个 `int`值就会转换成无符号数。把 `int`转换成无符号数的过程和把 `int`直接赋给无符号变量一样：

```cpp
int main()
{
    // 含有无符号类型的表达式
    unsigned u = 10;
    i = -42;
    std::cout << i + i << std::endl; // -84
    std::cout << u + i << std::endl; // 2^32-42+10 = 42949672564

    unsigned u1 = 42, u2 = 10;
    std::cout << u1 - u2 << std::endl;  // 32
    std::cout << u2 - u1 << std::endl;  // -32 -> 2^32-32 = 42949672564

    //无符号数不会小于这一事实同样关系到循环的写法。
    for(int j=10; j>=0; --j)
        std::cout << i << std::endl;

    /* 错误：变量k永远也不会小于0，循环条件一直成立
     * for(unsigned k=10; k>=0; --k)
     *    std::cout << j << std::endl;
     */

    return 0;
}
```

> **切勿混用带符号类型和无符号类型**
>
> 如果表达式里既有带符号类型又有无符号类型，当带符号类型取值为负时会出现异常结果，这是因为**带符号数会自动地转换成无符号数**。

```cpp
int main()
{
    // 练习2.3
    unsigned u = 10, u2 = 42;
    std::cout << u2 - u << std::endl;   // 32
    std::cout << u - u2 << std::endl;   // 42949672564

    int i = 10, i2 = 42;
    std::cout << i2 - i << std::endl;   // 32
    std::cout << i - i2 << std::endl;   // -32
    std::cout << i - u << std::endl;    // 0
    std::cout << u - i << std::endl;    // 0

    return 0;
}
```

### 2.1.3字面值常量

一个形如42的值被称作**字面值常量(literal)**，这样的值一望而知。每个字面值常量都对应一种数据类型，字面值常量的形式和值决定了它的数据类型。

- 整型和浮点型字面值

可以将整型字面值写作十进制数、八进制数或十六进制数的形式。以0开头的整数代表八进制数，以 `0x`或 `0X`开头的代表十六进制数。

```markdown
20 /*十进制*/
024 /*八进制*/
0x4 /*十六进制*/
```

整数字面值具体的数据类型由它的值和符号决定。**默认情况下，十进制字面值是带符号数**，类型是 `int long long long`中尺寸最小的那个。如果一个字面值连与之关联的最大的数据类型都放不下，将产生错误。**类型 `short`没有对应的字面值**。

浮点数字面值表现为一个小数或科学计数法表示的指数，其中指数部分用 `E`或 `e`标识：`3.14159 3.14E-1 0. 0e0 .001`。**默认的，浮点型字面值是一个 `double`**。

- 字符和字符串字面值

**由单引号括起来的一个字符称为 `char`型字面值；双引号括起来的零个或多个字符则构成字符串型字面值。**

```markdown
'a'	//字符字面值
"Hello World!"	//字符串字面值
```

如果两个字符串字面值位置紧邻且仅由空格、缩进和换行符分割，则它们实际上是一个整体。当书写的字符串字面值比较长，写在一行不太合适时，就可以采取分开书写的方式：

```cpp
// 分多行书写的字符串字面值
std::cout << "a really, really long string literal "
             "that spans two lines" << std::endl;

```

- 转义序列

有两类字符程序员不能直接使用：

1. 不可打印(nonprintable)的字符，如退格或其他控制字符，因为它们没有可视的图符；
2. 在C++语言中有特殊含义的字符(单引号、双引号、问好、反斜线)。

在这些情况下需要用到转义序列(escape sequence)，转义序列均以反斜线作为开始，C++语言规定的转义序列包括：

| 换行符 | \n     | 横向制表符 | \t     | 报警符 | \a     |
| ------ | ------ | ---------- | ------ | ------ | ------ |
| 退格符 | `\b` | 双引号     | `\"` | 单引号 | `'`  |
| 反斜线 | `\\` | 问号       | `\?` | 回车符 | `\r` |

也可以使用**泛化的转义序列**，其形式是 `\x`后紧跟1个或多个十六进制数字，或者 `\`后跟1个、2个或3个八进制数字，其中**数字部分表示的是字符对应的数值**。

> 注意：如果反斜线 `\`后面跟着的八进制数字超过3个，只有前3个数字与 `\`构成转义序列。例如，`\1234`表示2个字符，即八进制数123对应的字符以及字符4.
>
> 相反，`\x`要用到后面跟着的所有数字，例如，`\x1234`表示一个16位的字符，该字符由4个十六进制数所对应的比特唯一确定。

- 指定字面值的类型

通过添加如下表所列的前缀和后缀，可以改变整型、浮点型和字符型字面值的默认类型。

| 前缀               | 含义                        | 类型           |
| ------------------ | --------------------------- | -------------- |
| 字符和字符串字面值 |                             |                |
| `u`              | Unicode 16字符              | char16_t       |
| `U`              | Unicode 32字符              | char32_t       |
| `L`              | 宽字符                      | wchar_t        |
| `u8`             | UTF-8(仅用于字符串字面常量) | **char** |
| 整型字面值-后缀    |                             |                |
| `u` or `U`     | unsigned                    |                |
| `l` or `L`     | long                        |                |
| `ll` or `LL`   | long long                   |                |
| 浮点型字面值-后缀  |                             |                |
| `f` or `F`     | float                       |                |
| `l` or `L`     | long double                 |                |

- 布尔字面值和指针字面值

`true`和 `false`是布尔类型的字面值；`nullptr`是指针字面值。

```cpp
#include <iostream>

int main()
{
    //分多行书写的字符串字面值
    std::cout << "a really, really long string literal "
                "that spans two lines" << std::endl;    // a really, really long string literal that spans two lines

    // 指定字面值的类型
    L'a';   //宽字符型字面值，类型是wchar_t
    u8"hi!";    // utf-8字符串字面值(utf-8用8位编码一个Unicode字符)，类型是 char
    42ULL;  // 无符号整型字面值，类型是 unsigned long long 
    1E-3F;  // 单精度浮点型字面值，类型是 float
    3.14159L;   //扩展精度浮点型字面值，类型是 long double

    // 布尔字面值和指针字面值
    bool test = false;
    nullptr;    //指针字面值

    // 练习2.6
    int month = 9, day = 7;
    // int m = 09, d = 07; //八进制，且09无效的八进制

    // 练习2.8
    std::cout << "2" << "\115\n" << std::endl;       // 先输出2M，然后转到新一行
    std::cout << "2" << "\t\115\n" << std::endl;
    return 0;
}
```

## 2.2 变量

变量提供一个具名的、可供程序操作的存储空间。C++中的每个变量都有其数据类型，数据类型决定着变量所占内存空间的大小和布局方式、该空间能存储的值的范围，以及该变量能参与的运算。对C++程序员来说，“变量(variable)”和“对象(object)”一般可以互换使用。

### 2.2.1 变量定义

变量定义的基本形式是：首先是类型说明符，随后紧跟由一个或多个变量名组成的列表，其中变量名以逗号分隔，最后以分号结束。

> 通常情况下，对象是指一块能存储数据并具有某种类型的内存空间。

- 初始值

当对象**在创建时获得了一个特定的值**，就说这个对象被初始化(initialized)了。当一次定义了两个或多个变量时，对象的名字随着定义也就马上可以使用了。因此在同一条定义语句中，可以用先定义的变量值去初始化后定义的其他变量。

```cpp
#include <iostream>
#include <string>

int main()
{
    int sum = 0, value,
        unit_sold = 0;
    std::string book("0-201-78345-X");  //book通过一个string字面值初始化

    double salary = 9999.99, wage = salary;

    return 0;
}
```

> 在C++语言中，初始化和赋值是两个完全不同的操作。
>
> **初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。**

- 列表初始化

C++语言定义了初始化的好几种不同形式。例如，像定义一个名为a的int型变量并初始化为0，以下的4调语句都可以做到这一点：

```cpp
int a = 0;
int a = {0};	//列表初始化
int a{0};	//列表初始化
int a(0);
```

用花括号(`{}`)来初始化变量的形式被称为**列表初始化**(list initialization)。

**当用于内置类型的变量时，这种初始化形式有一个重要特点：如果我们要使用列表初始化且初始值存在丢失信息的风险，则编译器将报错**：

```cpp
//使用列表初始化且初始值存在丢失信息的风险时，编译器将报错
long double ld = 3.1415926536;
int a{ld}, b = {ld};    //错误：转换未执行，因为存在丢失信息的危险
int c(ld), d = ld;  //正确：转换执行，且确实丢失了部分值
```

- 默认初始化

如果**定义变量时没有指定初值，则变量被默认初始化(default initialized)**，此时变量被赋予了默认值。默认值到底是什么由变量类型决定，同时定义变量的位置也会对此有影响。

1. 如果是**内置类型**的变量未被显式初始化，它的值由**定义的位置**决定。定义任何函数体之外的变量被初始化为0。**定义在函数体内部的内置类型变量将不被初始化。一个未被初始化的内置类型变量的值是未定义的**，如果试图拷贝或以其他形式访问此类值将引发错误。
2. **每个类各自决定了其初始化对象的方式**。而且，是否允许不经初始化就定义对象也由类自己决定。绝大多数类都支持无须显式初始化而定义对象，这样的类提供了一个合适的默认值。

> 未初始化的变量含有一个不确定的值，使用未初始化变量的值是一种错误的编程行为而且很难调试。
>
> 建议初始化每一个内置类型的变量。

### 2.2.2 变量声明和定义的关系

为了允许把程序拆分成多个逻辑部分来编写，C++语言支持**分离式编译**机制，该机制允许将程序分割为若干个文件，每个文件可被单独编译。

为了支持分离式编译，C++语言将声明和定义区分开来。声明(declaration)使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而定义(define)负责创建与名字关联的实体。

> 变量声明规定了变量的类型和名字，在这一点上定义与之相同。但是除此之外，定义还申请了存储空间，也可能会为变量赋一个初始值。

如果想声明一个变量而非定义它，就在变量名前添加关键字 `extern`，而且不要显式地初始化变量。任何包含了显式初始化的声明即成为定义。

```cpp
#include <iostream>
#include <string>

// 在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错
extern double pi = 3.1415926;   //定义

int main()
{
    //声明
    extern int i;   //声明i而非定义i
    int j;          //声明并定义j

    return 0;
}
```

> 变量能且只能被定义一次，但是可以被多次声明。

**变量的定义必须出现且只能出现在一个文件中，而其他用到该变量的文件必须对其进行声明，却绝对不能重复定义。**

### 2.2.3 标识符

C++的标识符(identifier)由字母、数字和下划线组成，其中必须以字母或下划线开头。标识符的长度没有限制，但是对大小写字母敏感。

C++语言保留了一些名字供语言本身使用，这些名字不能被用作标识符。同时，C++也为标准库保留了一些名字。用户自定义的标识符不能连续出现两个下划线，也不能以下划线紧跟大写字母开头。此外，定义在函数体外的标识符不能以下划线开头。

**变量命名规范**

- 标识符要能体现实际含义
- 变量名一般用小写字母。
- 用户自定义的类名一般以大写字母开头，例如Sales_item。
- 如果标识符由多个单词组成，则单词间应有明显区分。如student_loan。

| C++      | 关键字   | 在此不一一列举 |
| -------- | -------- | -------------- |
| continue | register | if             |
| true     | new      | this           |

### 2.2.4 名字的作用域

**作用域**(scope)是程序的一部分，在其中名字有其特定的含义。C++语言中大多数作用域都以**花括号**分隔。

同一个名字在不同的作用域中可能指向不同的实体。**名字的有效区域始于名字的声明语句，以声明语句所在的作用域末端为结束**。

```cpp
#include<iostream>

/*
 * 程序定义了3个名字：main、sum和val
 * 同时使用了命名空间名字std，该空间提供了2个名字cout和cin供程序使用。
 * main定义于所有花括号意之外，拥有全局作用域
 * sum拥有块作用域
 * val定义于for语句内，在for语句之内可以访问val，但是在main函数的其他部分就不能访问它了
*/
int main()
{
    int sum = 0;
    for(int val=1; val<=10; ++val){
        sum += val;
    }
    std::cout << "Sum pf i to 10 inclusive is "
                << sum << std::endl;

    return 0;
}
```

- 嵌套的作用域

作用域中一旦声明了某个名字，它所嵌套着的所有作用域中都能访问该名字。同时，允许在内层作用域中重新定义外层作用域已有的名字：

```cpp
#include <iostream>
//该程序仅用于说明：函数内部不宜定义与全局变量同名的新变量。
int reused = 42;    //reused拥有全局作用域
int main()
{
    int unique = 0; //块作用域
    std::cout << reused << " " << unique << std::endl;      // 42 0
    int reused = 0; //新建局部变量，覆盖了全局变量 reused
    std::cout << reused << " " << unique << std::endl;      // 0 0
    //显式地访问全局变量reused
    std::cout << ::reused << " " << unique << std::endl;    // 42 0

    return 0;
}
```

> 因为全局作用域本身没有名字，所以当作用域操作符的左侧为空时，想全局作用域发出请求获取作用域操作符右侧名字对应的变量。
