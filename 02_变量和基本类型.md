## 2.1 基本内置类型

C++定义了一套包括**算术类型**和**空类型**在内的基本数据类型。其中**算术类型包含了字符、整数型、布尔值和浮点数**。**空类型不对应具体的值，仅用于一些特殊的场合**。

### 2.1.1 算术类型

算数类型分为：整型（integral type，包括字符和布尔类型在内）和浮点型。

布尔类型（bool）的取值是真(true)或者假(false)。

基本的字符类型是 `char`，一个 `char`的空间应确保可以存放机器基本字符集中任意字符对应的数字值。也就是说，一个 `char`的大小和一个机器字节一样。

> C++语言规定：
>
> sizeof(short) ≤ sizeof(int)≤ sizeof(long)≤ sizeof(long long)

> **内置类型的机器实现**
>
> 计算机以比特序列存储数据，每个比特非0即1。
>
> 大多数计算机以2的整数次幂个比特作为块来处理内存，可寻址的最小内存块称为“字节(byte)”，存储的基本单元称为“字(word)”，通常由几个字节组成。
>
> 大多数计算机将内存中的每个字节与一个数字（被称为“地址(address)”）关联起来。
>
> 为了赋予内存中某个地址明确的含义，必须首先知道存储在该地址的数据的类型。类型决定了数据所占的比特数以及该如何解释这些比特的内容。

浮点型可表示单精度、双精度和扩展精度值。通常，`float`以1个字（32比特）来表示，`double`以2个字（64比特）来表示。一般来说，类型 `float`和 `double`分别有7和16个有效位。

**带符号类型和无符号类型**

除去布尔型和扩展的字符型之外，其他整型可以划分为**带符号**(signed)的和**无符号**(unsigned)的两种。带符号类型可以表示正数、负数和0，无符号类型则仅能表示大于等于0的值。类型 `unsigned int`可以缩写为 `unsigned`。

无符号类型中所有比特都用来存储值。

> - 执行浮点数运算选用 `double`，因为 `float`通常精度不够而且双精度浮点数和单精度浮点数的计算代价相差无几。

### 2.1.2 类型转换

当在程序的某处我们使用了一种类型而其实对象应该取另一种类型时，程序会自动进行类型转换(convert)。

```cpp
#include <iostream>

int main()
{
    // 把一个非布尔类型的算术值赋给布尔类型时，初始值为0则结果为false，否则结果为true
    bool b = 42;        // b为真(true)
    int i = b;          // i = 1
    // 把浮点数赋给整数类型时，进行了近似处理。结果值将仅保留浮点数中小数点之前的部分
    i = 3.14;           // i = 3
    // 把整数赋给浮点数时，小数部分记为0.
    double pi = i;      // pi = 3.0
    // 当赋给无符号类型一个超出它表示范围的值时，结果是
    // 初始值对无符号类型表示数值总数取模后的余数。256 - 1 = 255 
    unsigned char c = -1;   // c = 255
    // 当赋给带符号类型一个超过它表示范围的值时，结果是未定义的(undefined)
    signed char c2 = 256;   //假设char占8比特，c2值是未定义的

    return 0;
}
```

- 含有无符号类型的表达式

当一个表达式中既有无符号又有 `int`值时，那个 `int`值就会转换成无符号数。把 `int`转换成无符号数的过程和把 `int`直接赋给无符号变量一样：

```cpp
int main()
{
    // 含有无符号类型的表达式
    unsigned u = 10;
    i = -42;
    std::cout << i + i << std::endl; // -84
    std::cout << u + i << std::endl; // 2^32-42+10 = 42949672564

    unsigned u1 = 42, u2 = 10;
    std::cout << u1 - u2 << std::endl;  // 32
    std::cout << u2 - u1 << std::endl;  // -32 -> 2^32-32 = 42949672564

    //无符号数不会小于这一事实同样关系到循环的写法。
    for(int j=10; j>=0; --j)
        std::cout << i << std::endl;

    /* 错误：变量k永远也不会小于0，循环条件一直成立
     * for(unsigned k=10; k>=0; --k)
     *    std::cout << j << std::endl;
     */

    return 0;
}
```

> **切勿混用带符号类型和无符号类型**
>
> 如果表达式里既有带符号类型又有无符号类型，当带符号类型取值为负时会出现异常结果，这是因为**带符号数会自动地转换成无符号数**。

```cpp
int main()
{
    // 练习2.3
    unsigned u = 10, u2 = 42;
    std::cout << u2 - u << std::endl;   // 32
    std::cout << u - u2 << std::endl;   // 42949672564

    int i = 10, i2 = 42;
    std::cout << i2 - i << std::endl;   // 32
    std::cout << i - i2 << std::endl;   // -32
    std::cout << i - u << std::endl;    // 0
    std::cout << u - i << std::endl;    // 0

    return 0;
}
```

### 2.1.3字面值常量

一个形如42的值被称作**字面值常量(literal)**，这样的值一望而知。每个字面值常量都对应一种数据类型，字面值常量的形式和值决定了它的数据类型。

- 整型和浮点型字面值

可以将整型字面值写作十进制数、八进制数或十六进制数的形式。以0开头的整数代表八进制数，以 `0x`或 `0X`开头的代表十六进制数。

```markdown
20 /*十进制*/
024 /*八进制*/
0x4 /*十六进制*/
```

整数字面值具体的数据类型由它的值和符号决定。**默认情况下，十进制字面值是带符号数**，类型是 `int long long long`中尺寸最小的那个。如果一个字面值连与之关联的最大的数据类型都放不下，将产生错误。**类型 `short`没有对应的字面值**。

浮点数字面值表现为一个小数或科学计数法表示的指数，其中指数部分用 `E`或 `e`标识：`3.14159 3.14E-1 0. 0e0 .001`。**默认的，浮点型字面值是一个 `double`**。

- 字符和字符串字面值

**由单引号括起来的一个字符称为 `char`型字面值；双引号括起来的零个或多个字符则构成字符串型字面值。**

```markdown
'a'	//字符字面值
"Hello World!"	//字符串字面值
```

如果两个字符串字面值位置紧邻且仅由空格、缩进和换行符分割，则它们实际上是一个整体。当书写的字符串字面值比较长，写在一行不太合适时，就可以采取分开书写的方式：

```cpp
// 分多行书写的字符串字面值
std::cout << "a really, really long string literal "
             "that spans two lines" << std::endl;

```

- 转义序列

有两类字符程序员不能直接使用：

1. 不可打印(nonprintable)的字符，如退格或其他控制字符，因为它们没有可视的图符；
2. 在C++语言中有特殊含义的字符(单引号、双引号、问好、反斜线)。

在这些情况下需要用到转义序列(escape sequence)，转义序列均以反斜线作为开始，C++语言规定的转义序列包括：

| 换行符 | \n     | 横向制表符 | \t     | 报警符 | \a     |
| ------ | ------ | ---------- | ------ | ------ | ------ |
| 退格符 | `\b` | 双引号     | `\"` | 单引号 | `'`  |
| 反斜线 | `\\` | 问号       | `\?` | 回车符 | `\r` |

也可以使用**泛化的转义序列**，其形式是 `\x`后紧跟1个或多个十六进制数字，或者 `\`后跟1个、2个或3个八进制数字，其中**数字部分表示的是字符对应的数值**。

> 注意：如果反斜线 `\`后面跟着的八进制数字超过3个，只有前3个数字与 `\`构成转义序列。例如，`\1234`表示2个字符，即八进制数123对应的字符以及字符4.
>
> 相反，`\x`要用到后面跟着的所有数字，例如，`\x1234`表示一个16位的字符，该字符由4个十六进制数所对应的比特唯一确定。

- 指定字面值的类型

通过添加如下表所列的前缀和后缀，可以改变整型、浮点型和字符型字面值的默认类型。

| 前缀               | 含义                        | 类型           |
| ------------------ | --------------------------- | -------------- |
| 字符和字符串字面值 |                             |                |
| `u`              | Unicode 16字符              | char16_t       |
| `U`              | Unicode 32字符              | char32_t       |
| `L`              | 宽字符                      | wchar_t        |
| `u8`             | UTF-8(仅用于字符串字面常量) | **char** |
| 整型字面值-后缀    |                             |                |
| `u` or `U`     | unsigned                    |                |
| `l` or `L`     | long                        |                |
| `ll` or `LL`   | long long                   |                |
| 浮点型字面值-后缀  |                             |                |
| `f` or `F`     | float                       |                |
| `l` or `L`     | long double                 |                |

- 布尔字面值和指针字面值

`true`和 `false`是布尔类型的字面值；`nullptr`是指针字面值。

```cpp
#include <iostream>

int main()
{
    //分多行书写的字符串字面值
    std::cout << "a really, really long string literal "
                "that spans two lines" << std::endl;    // a really, really long string literal that spans two lines

    // 指定字面值的类型
    L'a';   //宽字符型字面值，类型是wchar_t
    u8"hi!";    // utf-8字符串字面值(utf-8用8位编码一个Unicode字符)，类型是 char
    42ULL;  // 无符号整型字面值，类型是 unsigned long long 
    1E-3F;  // 单精度浮点型字面值，类型是 float
    3.14159L;   //扩展精度浮点型字面值，类型是 long double

    // 布尔字面值和指针字面值
    bool test = false;
    nullptr;    //指针字面值

    // 练习2.6
    int month = 9, day = 7;
    // int m = 09, d = 07; //八进制，且09无效的八进制

    // 练习2.8
    std::cout << "2" << "\115\n" << std::endl;       // 先输出2M，然后转到新一行
    std::cout << "2" << "\t\115\n" << std::endl;
    return 0;
}
```
