## 2.1 基本内置类型

C++定义了一套包括**算术类型**和**空类型**在内的基本数据类型。其中**算术类型包含了字符、整数型、布尔值和浮点数**。**空类型不对应具体的值，仅用于一些特殊的场合**。

### 2.1.1 算术类型

算数类型分为：整型（integral type，包括字符和布尔类型在内）和浮点型。

布尔类型（bool）的取值是真(true)或者假(false)。

基本的字符类型是 `char`，一个 `char`的空间应确保可以存放机器基本字符集中任意字符对应的数字值。也就是说，一个 `char`的大小和一个机器字节一样。

> C++语言规定：
>
> sizeof(short) ≤ sizeof(int)≤ sizeof(long)≤ sizeof(long long)

> **内置类型的机器实现**
>
> 计算机以比特序列存储数据，每个比特非0即1。
>
> 大多数计算机以2的整数次幂个比特作为块来处理内存，可寻址的最小内存块称为“字节(byte)”，存储的基本单元称为“字(word)”，通常由几个字节组成。
>
> 大多数计算机将内存中的每个字节与一个数字（被称为“地址(address)”）关联起来。
>
> 为了赋予内存中某个地址明确的含义，必须首先知道存储在该地址的数据的类型。类型决定了数据所占的比特数以及该如何解释这些比特的内容。

浮点型可表示单精度、双精度和扩展精度值。通常，`float`以1个字（32比特）来表示，`double`以2个字（64比特）来表示。一般来说，类型 `float`和 `double`分别有7和16个有效位。

**带符号类型和无符号类型**

除去布尔型和扩展的字符型之外，其他整型可以划分为**带符号**(signed)的和**无符号**(unsigned)的两种。带符号类型可以表示正数、负数和0，无符号类型则仅能表示大于等于0的值。类型 `unsigned int`可以缩写为 `unsigned`。

无符号类型中所有比特都用来存储值。

> - 执行浮点数运算选用 `double`，因为 `float`通常精度不够而且双精度浮点数和单精度浮点数的计算代价相差无几。

### 2.1.2 类型转换

当在程序的某处我们使用了一种类型而其实对象应该取另一种类型时，程序会自动进行类型转换(convert)。

```cpp
#include <iostream>

int main()
{
    // 把一个非布尔类型的算术值赋给布尔类型时，初始值为0则结果为false，否则结果为true
    bool b = 42;        // b为真(true)
    int i = b;          // i = 1
    // 把浮点数赋给整数类型时，进行了近似处理。结果值将仅保留浮点数中小数点之前的部分
    i = 3.14;           // i = 3
    // 把整数赋给浮点数时，小数部分记为0.
    double pi = i;      // pi = 3.0
    // 当赋给无符号类型一个超出它表示范围的值时，结果是
    // 初始值对无符号类型表示数值总数取模后的余数。256 - 1 = 255 
    unsigned char c = -1;   // c = 255
    // 当赋给带符号类型一个超过它表示范围的值时，结果是未定义的(undefined)
    signed char c2 = 256;   //假设char占8比特，c2值是未定义的

    return 0;
}
```

- 含有无符号类型的表达式

当一个表达式中既有无符号又有 `int`值时，那个 `int`值就会转换成无符号数。把 `int`转换成无符号数的过程和把 `int`直接赋给无符号变量一样：

```cpp
int main()
{
    // 含有无符号类型的表达式
    unsigned u = 10;
    i = -42;
    std::cout << i + i << std::endl; // -84
    std::cout << u + i << std::endl; // 2^32-42+10 = 42949672564

    unsigned u1 = 42, u2 = 10;
    std::cout << u1 - u2 << std::endl;  // 32
    std::cout << u2 - u1 << std::endl;  // -32 -> 2^32-32 = 42949672564

    //无符号数不会小于这一事实同样关系到循环的写法。
    for(int j=10; j>=0; --j)
        std::cout << i << std::endl;

    /* 错误：变量k永远也不会小于0，循环条件一直成立
     * for(unsigned k=10; k>=0; --k)
     *    std::cout << j << std::endl;
     */

    return 0;
}
```

> **切勿混用带符号类型和无符号类型**
>
> 如果表达式里既有带符号类型又有无符号类型，当带符号类型取值为负时会出现异常结果，这是因为**带符号数会自动地转换成无符号数**。

```cpp
int main()
{
    // 练习2.3
    unsigned u = 10, u2 = 42;
    std::cout << u2 - u << std::endl;   // 32
    std::cout << u - u2 << std::endl;   // 42949672564

    int i = 10, i2 = 42;
    std::cout << i2 - i << std::endl;   // 32
    std::cout << i - i2 << std::endl;   // -32
    std::cout << i - u << std::endl;    // 0
    std::cout << u - i << std::endl;    // 0

    return 0;
}
```

### 2.1.3字面值常量

一个形如42的值被称作**字面值常量(literal)**，这样的值一望而知。每个字面值常量都对应一种数据类型，字面值常量的形式和值决定了它的数据类型。

- 整型和浮点型字面值

可以将整型字面值写作十进制数、八进制数或十六进制数的形式。以0开头的整数代表八进制数，以 `0x`或 `0X`开头的代表十六进制数。

```markdown
20 /*十进制*/
024 /*八进制*/
0x4 /*十六进制*/
```

整数字面值具体的数据类型由它的值和符号决定。**默认情况下，十进制字面值是带符号数**，类型是 `int long long long`中尺寸最小的那个。如果一个字面值连与之关联的最大的数据类型都放不下，将产生错误。**类型 `short`没有对应的字面值**。

浮点数字面值表现为一个小数或科学计数法表示的指数，其中指数部分用 `E`或 `e`标识：`3.14159 3.14E-1 0. 0e0 .001`。**默认的，浮点型字面值是一个 `double`**。

- 字符和字符串字面值

**由单引号括起来的一个字符称为 `char`型字面值；双引号括起来的零个或多个字符则构成字符串型字面值。**

```markdown
'a'	//字符字面值
"Hello World!"	//字符串字面值
```

如果两个字符串字面值位置紧邻且仅由空格、缩进和换行符分割，则它们实际上是一个整体。当书写的字符串字面值比较长，写在一行不太合适时，就可以采取分开书写的方式：

```cpp
// 分多行书写的字符串字面值
std::cout << "a really, really long string literal "
             "that spans two lines" << std::endl;

```

- 转义序列

有两类字符程序员不能直接使用：

1. 不可打印(nonprintable)的字符，如退格或其他控制字符，因为它们没有可视的图符；
2. 在C++语言中有特殊含义的字符(单引号、双引号、问好、反斜线)。

在这些情况下需要用到转义序列(escape sequence)，转义序列均以反斜线作为开始，C++语言规定的转义序列包括：

| 换行符 | \n     | 横向制表符 | \t     | 报警符 | \a     |
| ------ | ------ | ---------- | ------ | ------ | ------ |
| 退格符 | `\b` | 双引号     | `\"` | 单引号 | `'`  |
| 反斜线 | `\\` | 问号       | `\?` | 回车符 | `\r` |

也可以使用**泛化的转义序列**，其形式是 `\x`后紧跟1个或多个十六进制数字，或者 `\`后跟1个、2个或3个八进制数字，其中**数字部分表示的是字符对应的数值**。

> 注意：如果反斜线 `\`后面跟着的八进制数字超过3个，只有前3个数字与 `\`构成转义序列。例如，`\1234`表示2个字符，即八进制数123对应的字符以及字符4.
>
> 相反，`\x`要用到后面跟着的所有数字，例如，`\x1234`表示一个16位的字符，该字符由4个十六进制数所对应的比特唯一确定。

- 指定字面值的类型

通过添加如下表所列的前缀和后缀，可以改变整型、浮点型和字符型字面值的默认类型。

| 前缀               | 含义                        | 类型           |
| ------------------ | --------------------------- | -------------- |
| 字符和字符串字面值 |                             |                |
| `u`              | Unicode 16字符              | char16_t       |
| `U`              | Unicode 32字符              | char32_t       |
| `L`              | 宽字符                      | wchar_t        |
| `u8`             | UTF-8(仅用于字符串字面常量) | **char** |
| 整型字面值-后缀    |                             |                |
| `u` or `U`     | unsigned                    |                |
| `l` or `L`     | long                        |                |
| `ll` or `LL`   | long long                   |                |
| 浮点型字面值-后缀  |                             |                |
| `f` or `F`     | float                       |                |
| `l` or `L`     | long double                 |                |

- 布尔字面值和指针字面值

`true`和 `false`是布尔类型的字面值；`nullptr`是指针字面值。

```cpp
#include <iostream>

int main()
{
    //分多行书写的字符串字面值
    std::cout << "a really, really long string literal "
                "that spans two lines" << std::endl;    // a really, really long string literal that spans two lines

    // 指定字面值的类型
    L'a';   //宽字符型字面值，类型是wchar_t
    u8"hi!";    // utf-8字符串字面值(utf-8用8位编码一个Unicode字符)，类型是 char
    42ULL;  // 无符号整型字面值，类型是 unsigned long long 
    1E-3F;  // 单精度浮点型字面值，类型是 float
    3.14159L;   //扩展精度浮点型字面值，类型是 long double

    // 布尔字面值和指针字面值
    bool test = false;
    nullptr;    //指针字面值

    // 练习2.6
    int month = 9, day = 7;
    // int m = 09, d = 07; //八进制，且09无效的八进制

    // 练习2.8
    std::cout << "2" << "\115\n" << std::endl;       // 先输出2M，然后转到新一行
    std::cout << "2" << "\t\115\n" << std::endl;
    return 0;
}
```

## 2.2 变量

变量提供一个具名的、可供程序操作的存储空间。C++中的每个变量都有其数据类型，数据类型决定着变量所占内存空间的大小和布局方式、该空间能存储的值的范围，以及该变量能参与的运算。对C++程序员来说，“变量(variable)”和“对象(object)”一般可以互换使用。

### 2.2.1 变量定义

变量定义的基本形式是：首先是类型说明符，随后紧跟由一个或多个变量名组成的列表，其中变量名以逗号分隔，最后以分号结束。

> 通常情况下，对象是指一块能存储数据并具有某种类型的内存空间。

- 初始值

当对象**在创建时获得了一个特定的值**，就说这个对象被初始化(initialized)了。当一次定义了两个或多个变量时，对象的名字随着定义也就马上可以使用了。因此在同一条定义语句中，可以用先定义的变量值去初始化后定义的其他变量。

```cpp
#include <iostream>
#include <string>

int main()
{
    int sum = 0, value,
        unit_sold = 0;
    std::string book("0-201-78345-X");  //book通过一个string字面值初始化

    double salary = 9999.99, wage = salary;

    return 0;
}
```

> 在C++语言中，初始化和赋值是两个完全不同的操作。
>
> **初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。**

- 列表初始化

C++语言定义了初始化的好几种不同形式。例如，像定义一个名为a的int型变量并初始化为0，以下的4调语句都可以做到这一点：

```cpp
int a = 0;
int a = {0};	//列表初始化
int a{0};	//列表初始化
int a(0);
```

用花括号(`{}`)来初始化变量的形式被称为**列表初始化**(list initialization)。

**当用于内置类型的变量时，这种初始化形式有一个重要特点：如果我们要使用列表初始化且初始值存在丢失信息的风险，则编译器将报错**：

```cpp
//使用列表初始化且初始值存在丢失信息的风险时，编译器将报错
long double ld = 3.1415926536;
int a{ld}, b = {ld};    //错误：转换未执行，因为存在丢失信息的危险
int c(ld), d = ld;  //正确：转换执行，且确实丢失了部分值
```

- 默认初始化

如果**定义变量时没有指定初值，则变量被默认初始化(default initialized)**，此时变量被赋予了默认值。默认值到底是什么由变量类型决定，同时定义变量的位置也会对此有影响。

1. 如果是**内置类型**的变量未被显式初始化，它的值由**定义的位置**决定。定义任何函数体之外的变量被初始化为0。**定义在函数体内部的内置类型变量将不被初始化。一个未被初始化的内置类型变量的值是未定义的**，如果试图拷贝或以其他形式访问此类值将引发错误。
2. **每个类各自决定了其初始化对象的方式**。而且，是否允许不经初始化就定义对象也由类自己决定。绝大多数类都支持无须显式初始化而定义对象，这样的类提供了一个合适的默认值。

> 未初始化的变量含有一个不确定的值，使用未初始化变量的值是一种错误的编程行为而且很难调试。
>
> 建议初始化每一个内置类型的变量。

### 2.2.2 变量声明和定义的关系

为了允许把程序拆分成多个逻辑部分来编写，C++语言支持**分离式编译**机制，该机制允许将程序分割为若干个文件，每个文件可被单独编译。

为了支持分离式编译，C++语言将声明和定义区分开来。声明(declaration)使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而定义(define)负责创建与名字关联的实体。

> 变量声明规定了变量的类型和名字，在这一点上定义与之相同。但是除此之外，定义还申请了存储空间，也可能会为变量赋一个初始值。

如果想声明一个变量而非定义它，就在变量名前添加关键字 `extern`，而且不要显式地初始化变量。任何包含了显式初始化的声明即成为定义。

```cpp
#include <iostream>
#include <string>

// 在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错
extern double pi = 3.1415926;   //定义

int main()
{
    //声明
    extern int i;   //声明i而非定义i
    int j;          //声明并定义j

    return 0;
}
```

> 变量能且只能被定义一次，但是可以被多次声明。

**变量的定义必须出现且只能出现在一个文件中，而其他用到该变量的文件必须对其进行声明，却绝对不能重复定义。**

### 2.2.3 标识符

C++的标识符(identifier)由字母、数字和下划线组成，其中必须以字母或下划线开头。标识符的长度没有限制，但是对大小写字母敏感。

C++语言保留了一些名字供语言本身使用，这些名字不能被用作标识符。同时，C++也为标准库保留了一些名字。用户自定义的标识符不能连续出现两个下划线，也不能以下划线紧跟大写字母开头。此外，定义在函数体外的标识符不能以下划线开头。

**变量命名规范**

- 标识符要能体现实际含义
- 变量名一般用小写字母。
- 用户自定义的类名一般以大写字母开头，例如Sales_item。
- 如果标识符由多个单词组成，则单词间应有明显区分。如student_loan。

```cpp
#include <iostream>

int main()
{
    //练习2.12：请说明下面的名字中哪些是非法的？
    // int double = 3.14;  //错误：变量名不能与关键字相同
    int _;              //可以
    // int catch-22;       //错误：不能有字母、下划线、数字之外的字符
    // int 1_or_2;         //错误：不能以数字开头
    double Double = 3.14;   //对

    return 0;
}
```

| C++      | 关键字   | 在此不一一列举 |
| -------- | -------- | -------------- |
| continue | register | if             |
| true     | new      | this           |

### 2.2.4 名字的作用域

**作用域**(scope)是程序的一部分，在其中名字有其特定的含义。C++语言中大多数作用域都以**花括号**分隔。

同一个名字在不同的作用域中可能指向不同的实体。**名字的有效区域始于名字的声明语句，以声明语句所在的作用域末端为结束**。

```cpp
#include<iostream>

/*
 * 程序定义了3个名字：main、sum和val
 * 同时使用了命名空间名字std，该空间提供了2个名字cout和cin供程序使用。
 * main定义于所有花括号意之外，拥有全局作用域
 * sum拥有块作用域
 * val定义于for语句内，在for语句之内可以访问val，但是在main函数的其他部分就不能访问它了
*/
int main()
{
    int sum = 0;
    for(int val=1; val<=10; ++val){
        sum += val;
    }
    std::cout << "Sum pf i to 10 inclusive is "
                << sum << std::endl;

    return 0;
}
```

- 嵌套的作用域

作用域中一旦声明了某个名字，它所嵌套着的所有作用域中都能访问该名字。同时，允许在内层作用域中重新定义外层作用域已有的名字：

```cpp
#include <iostream>
//该程序仅用于说明：函数内部不宜定义与全局变量同名的新变量。
int reused = 42;    //reused拥有全局作用域
int main()
{
    int unique = 0; //块作用域
    std::cout << reused << " " << unique << std::endl;      // 42 0
    int reused = 0; //新建局部变量，覆盖了全局变量 reused
    std::cout << reused << " " << unique << std::endl;      // 0 0
    //显式地访问全局变量reused
    std::cout << ::reused << " " << unique << std::endl;    // 42 0

    return 0;
}
```

> 因为全局作用域本身没有名字，所以当作用域操作符的左侧为空时，想全局作用域发出请求获取作用域操作符右侧名字对应的变量。

## 2.3 复合类型

**符合类型(compoud type)**是指基于其他类型定义的类型。

一条声明语句由一个基本数据类型(base type)和紧随其后的一个声明符(declarator)列表组成。每个声明符命名了一个变量并指定该变量为与基本数据类型有关的某种类型。

### 2.3.1 引用

引用(reference)为对象起了另外一个别名，引用类型引用(refer to)另外一种类型。通过将声明符写成 `&d`的形式来定义引用类型，其中d是声明的变量名。

定义引用时，程序把引用和它的初始值绑定(bind)在一起，而不是将初始值拷贝给引用。**一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另一个对象，因此引用必须初始化**。

> 引用并非对象。相反的，它只是一个已经存在的对象所起的另外一个名字。
>
> 因为引用本身不是一个对象，所以不能定义引用的引用。

引用的类型要和与之绑定的对象严格匹配。而且，**引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起**。

```cpp
int main()
{
    int ival = 1024;
    int &refVal = ival;
    // int &refVal2;   // 报错：引用必须初始化！

    refVal = 2;
    int ii = refVal;    //与 ii = ival 执行结果一样

    //引用只能绑定在对象上，而不能与字面值或某个表达式的结果绑定在一起
    // int &refVal2 = 10;  //错误：引用类型的初始值必须是一个对象
    double dval = 3.14;
    // int &refVal3 = dval;    //错误：此处引用类型的初始值必须是int型对象

    return 0;
}
```

### 2.3.2 指针

指针(pointer)是“指向(point to)”另外一种类型的复合类型。与引用类似，指针也实现了对其他对象的间接访问。

> 指针和引用的主要区别：
>
> 1. 引用是另一个对象的别名。引用必须初始化，并且一旦定义了引用就无法再绑定到其他对象。
> 2. 指针本身就是一个对象。指针无须在定义时赋初值，也可以重新赋值让其指向其他对象。

定义指针类型的方法将声明符写成 `*d`的形式，其中d是变量名。

- 获取对象的地址

**指针存放某个对象的地址，要想获取该地址，需要使用取地址符(操作符 `&`)**。在声明语句中指针的类型实际上被用于指定它所指向对象的类型,所以二者必须匹配.

```cpp
int main()
{
    int ival = 42;
    int *p = &ival; //p存放变量ival的地址，或者说p是指向变量ival的指针

    //指针的类型要和它所指的对象严格匹配
    double dval;
    double *pd = &dval;
    double *pd2 = pd;

    // int *pi = pd;   //错误：类型不匹配
    // pi = &dval;     //错误：类型不匹配

    return 0;
}
```

**指针值**:指针的值(即地址)应属于下列4种状态之一:

1. 指向一个对象
2. 指向紧邻对象所占空间的下一个位置
3. 空指针,意味着指针没有指向任何对象.
4. 无效指针,也就是上述情况之外的其他值

- 利用指针访问对象

如果指针指向了一个对象,则允许使用解引用符 `*`来访问该对象.解引用仅适用于那些确实指向了某个对象的有效指针.

```cpp
int main()
{
    int ival = 42;
    int *p = &ival; //p存放变量ival的地址，或者说p是指向变量ival的指针

    //指针的类型要和它所指的对象严格匹配
    double dval;
    double *pd = &dval;
    double *pd2 = pd;

    // int *pi = pd;   //错误：类型不匹配
    // pi = &dval;     //错误：类型不匹配

    //利用指针访问对象
    std::cout << *p << std::endl;   // 42

    return 0;
}
```

- **空指针**

**空指针(null pointer)不指向任何对象**,在试图使用一个指针之前代码可以首先检查它是否为空.等到空指针最直接的办法就是用字面值 `nullptr`来初始化指针.

```cpp
//空指针
int *p1 = nullptr;  //nullptr空指针字面值
int *p2 = 0;        //与上等价
// 需要首先 #include <cstdlib>
int *p3 = NULL;     //等价于 int *p3 = 0;
//把int变量直接赋给指针是错误的操作,即使int变量的值恰好等于0也不行
int zero = 0;
// int *pi = zero;  //错误:不能把int变量直接赋给指针
```

> 过去的程序还会使用到一个名为 `NULL`的预处理变量来给指针赋值,这个变量在头文件 `cstdlib`中定义,它的值为0.
>
> 预处理器是在运行于编译过程之前的一段程序.预处理变量不属于命名空间std,它由预处理器负责管理,因此可以直接使用预处理变量而无须在前面加上 `std::`.
>
> 当用到一个预处理变量时,预处理器会自动地将它替换为实际值,因此 `NULL`初始化指针和用0初始化指针是一样的.

- 其他指针操作

如果指针的值是0,条件取false;任何非0指针对应的条件值都是true.

```cpp
//其他指针操作
int *pi = 0;
if(pi)
    std::cout << "pi的值为0,因此条件的值是false" << std::endl;

if(*pi)
    std::cout << "pi指向的值是0,因此条件是false" << std::endl;

//如果两个指针存放的地址值相同,则它们相等
//地址值相等由三种可能:都为空;都指向同一个对象;都指向了用一个对象的下一个地址

```

- void*指针

`void*`是一种特殊的指针类型,可用于存放任意对象的地址.但我们对该地址到底是个什么类型的对象并不了解.

```cpp
//void*指针
double obj = 3.14, *pd3 = &obj;
void *pv = &obj;    //obj可以是任意类型的对象
pv = pd3;
```

### 2.3.3 理解符合类型的声明

在同一条定义语句中,虽然基本数据类型只有一个,但是声明符的形式却可以不同.也就是说,一条定义语句可能定义出不同类型的变量:

```cpp
int i = 1024, *p = &i, &r = i;
```

- 指向指针的指针

一般来说,声明符中修饰符的个数并没有限制.通过 `*`的个数可以区分指针的级别.也就是说,`**`表示指向指针的指针,`***`表示指向指针的指针的指针.

```cpp
int ival = 1024;
int *pi = &ival;
int **ppi = & pi;	//指向一个int型的指针
```

- 指向指针的引用

引用本身不是一个对象,因此不能定义指向引用的指针.但指针是对象,所以存在对象指针的引用.

```cpp
int main()
{
    //指向指针的引用
    int i = 42;
    int *p;         //p是一个int型指针
    int *&r = p;    //r是指针p的引用
    r = &i;         //使p指向i
    *r = 0;         //使i值为0

    return 0;
}
```

> 要理解r的类型到底是什么,最简单的办法是从右小左阅读r的定义.离变量最近的符号(此例中是 `&r`中的 `&`)对变量的类型有最直接的影响,因此r是一个引用.声明符其余部分用以确定r引用的类型是什么,此例中的符号 `*`说明r引用的是一个指针.最后,声明的基本数据类型部分指出r引用的是一个int指针.

```cpp
//练习2.25
int *ip, ii, &r = ii;   // ip指针;ii整型;r引用
int iii, *iip = 0;      //iii整型;iip空指针
int* iiip, ip2;		// iiip指针;ip2整型
```
