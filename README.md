# cpp_perimer

### 1.4.3 读取数量不定的输入数据

预先不知道要对多少个数求和，需要不断读取数据直到没有新的输入为止：

```cpp
int main()
{
    int sum = 0, value;
    //当有输入时就继续循环，没有输入时就停止循环
    //当使用一个 istream 对象作为条件时，其效果是检测流的状态。如果流是有效的，即流未遇到错误，那么检测成功。
    //当遇到
    while(std::cin >> value){   //按Ctrl+Z表示输入结束
        sum2 += value;
    }
    std::cout << "Sum is: " << sum << std::endl;
    return 0;
}
```

当使用一个 `istream`对象作为条件时，其效果是检测流的状态。如果流是有效的，即流未遇到错误，那么检测成功。当遇到**文件结束符**，或遇到一个无效输入时（例如读入的值不是一个整数），`istream`对象的状态会变为无效。处于无效状态的会使条件变为假。

> **从键盘输入文件结束符**
>
> 当从键盘向程序输入数据时，对于如何指出文件结束，不同操作系统有不同的约定。在Windows系统中，输入文件结束符的方法是敲 `Ctrl+Z`，然后按 `Enter`键。在Unix系统中，包括Mac OS X系统中，文件结束符输入是用 `Ctrl+D`

> **再探编译**
>
> 编译器的一部分工作是寻找程序文本中的错误。编译器没有能力检查一个程序是否按照作者的意图工作，但可以检查形式（form）上的错误。
>
> 1. 语法错误(syntax error)：
> 2. 类型错误(type error)：C++中每个数据项都有其类型。
> 3. 声明错误(declaration error)：C++程序中的每个名字都要先声明后使用。名字声明失败，通常会导致一条错误信息。两种常见的声明错误是：对来自标准库的名字忘记使用 `std::`、标识符名字拼写错误。
>
> 错误信息通常包含一个行号和一条简短描述，描述了编译器认位我们所犯的错误。按照报告顺序来诸葛修正错误，是一种好习惯。另一个好习惯是在每修正一个错误后就立即重新编译代码，或者最多修正了一小部分明显的错误后就重新编译。这就是所谓的“编辑-编译-调试”(edit-compile-debug)周期。

```cpp
    //练习1.16
    int sum = 0, value;
    while(std::cin >> value){
        sum += value;
    }
    std::cout << "sum is " << sum << std::endl;
```

### 1.4.4 if语句

用 `if`语句写一个程序，来统计在输入中每个值连续出现了多少次：

```cpp
int main()
{
    //统计在输入中每个值连续出现了多少次
    //currVal是正在统计的数，将读入的新值存入val
    int currVal = 0, val = 0;
    if(std::cin >> currVal){	//保证输入不为空
        int cnt = 1;
        while(std::cin >> val){
            if(val == currVal){
                ++cnt;
            }else{
                std::cout << currVal << " occurs "
                        << cnt << " times" << std::endl;
                currVal = val;
                cnt = 1;
            }
        }
        std::cout << currVal << " occurs "
                << cnt << " times" << std::endl;
    }

    return 0;
}
```

> C++用 `=`进行赋值，用 `==`作为相等运算符。两个运算符都可以出现在条件中 。

## 1.5 类简介

在C++中，我们通过定义一个**类**(class)来定义自己的数据结构。一个类定义了一个类型，以及与其关联的一组操作。

为了使用类，我们需要了解三件事情：

- 类名是什么？
- 它是在哪里定义的？
- 它支持什么操作？

习惯上，头文件根据其中定义的类的名字来命名。通常使用 `.h`作为头文件的后缀。标准头文件通常不带后缀。

### 1.5.1 Sales_item 类

每个类实际上都定义了一个新的类型，其类型名就是类名。与内置类型一样，可以定义类类型的变量。

```cpp
#include <iostream>
#include "Sales_item.h"
//包含来自标准库的头文件是，应该使用尖括号(<>)包围文件名
//对于不属于标准库的头文件，则用双引号("")包围。

int main()
{
    Sales_item book;    //定义类类型的变量
    //读入ISBN号、售出的册数以及销售价格
    std::cin >> book;
    //写入ISBN、售出的册数、总销售额和平均价格
    std::cout << book << std::endl;
  
    //Sales_item对象的加法
    Sales_item item1, item2;
    std::cin >> item1 >> item2;                 //读取一对交易记录
    std::cout << item1 + item2 << std::endl;    //打印它们的和

    return 0;
}
```

> 使用文件重定向
>
> 当测试程序时，反复从键盘敲入这些销售记录作为程序输入，是非常乏味的。大多数操作系统支持文件重定向，这种机制允许我们**将标准输入和标准输出与命名文件关联起来**：
>
> `$ addItems < infile > outfile`
>
> 假定 `$`是系统提示符，我们的加法程序已经编译为名为 `addItems.exe`的可执行文件，则上述命令会从一个名为 `infile`的文件读取销售记录，并将结果写入到一个名为 `outfile`的文件中，两个文件都位于当前目录下。

```cpp
#include <iostream>
#include "../Sales_item.h"

int main()
{
    //练习1.20
    for(Sales_item book; std::cin >> book; std::cout << book << std::endl);
    //编译：g++ --std=c++11 01_20.cpp -o main
    //文件重定向：main.exe < add_item

    //练习1.21
    Sales_item item1, item2;
    std::cin >> item1 >> item2;
    std::cout << "sum of item1 and item2 is " << item1 + item2 << std::endl;

    //练习1.22
    Sales_item sum_item, item;
    std::cin >> sum_item;
    while(std::cin >> item){
        sum_item += item;
    }
    std::cout << "sum of items is " << sum_item << std::endl;

    return 0;
}
```

### 1.5.2 初识成员函数

将两个Sales_item对象相加的程序首先应该检查两个对象是否具有相同的ISBN。

```cpp
int main()
{
    Sales_item item1, item2;
    std::cin >> item1 >> item2;
    //首先检查item1和item2是否表示相同的书
    if(item1.isbn() == item2.isbn()){
        std::cout << item1 + item2 << std::endl;
        return 0;   //表示成功
    }else{
        std::cerr << "Data must refer to same ISBN"
                    << std::endl;
        return -1;  //表示失败
    }
}
```

**成员函数**(member function)是定义为类的一部分的函数，有时也成为**方法**(method)。通常以一个类对象的名义来调用成员函数。`item1.isbn()`使用**点运算符**(`.`)来表达需要“名为item1的对象的isbn成员”。**点运算符只能用于类类型的对象，其左侧运算对象必须是一个类类型的对象，右侧运算对象必须是该类型的一个成员名，运算结果为右侧运算对象指定的成员**。

```cpp
int main()
{
    //练习1.23 编写程序，读取多条销售记录，并统计每个ISBN(每本书)有几条销售记录
    // Sales_item currItem, item;
    // if(std::cin >> currItem){
    //     int cnt = 1;
    //     while(std::cin >> item){
    //         if(item.isbn() == currItem.isbn()){
    //             ++cnt;
    //         }else{
    //             std::cout << currItem.isbn() << " occurs "
    //                         << cnt << " times" << std::endl;
    //             currItem = item;
    //             cnt = 1;
    //         }
    //     }
    //     std::cout << currItem.isbn() << " occurs "
    //                 << cnt << " times" << std::endl;
    // }

    //练习1.24
    Sales_item total;
    if(std::cin >> total){
        Sales_item trans;
        while(std::cin >> trans){
            if(trans.isbn() == total.isbn()){
                total += trans;
            }else{
                std::cout << total << std::endl;
                total = trans;
            }
        }
        std::cout << total <<  std::endl;
    }else{
        std::cerr << "No data?" << std::endl;
        return -1;
    }

    return 0;
}
```

## 术语表

**赋值(assignment)**：抹去一个对象的当前值，用一个新值取代之。

**缓冲区(buffer)**：一个存储区域，用于保存数据。IO设施通常将输入（或输出）数据保存在一个缓冲区中，读写缓冲区的动作与程序中的动作是无关的，可以显式地刷新输出缓冲，以便强制将缓冲区中的数据写入输出设备。默认情况下，读 `cin`会刷新 `cout`；程序非正常终止也会刷新 `cout`。

**注释(comment)**：被编译器忽略的程序文本。C++有两种类型的注释：单行注释和界定符对注释。

**表达式(expression)**：最小的计算单元。

**头文件(header)**：使类或其他名字的定义可被多个程序使用的一种机制。程序通过 `#include`指令使用头文件。

**初始化(initialize)**：在一个对象创建的时候赋予它一个值。

**库类型(library type)**：标准库定义的类型，如 `istream`。

**命名空间(namespace)**：将库定义的名字放在一个单一位置的机制。命名空间可以帮助避免不经意的名字冲突。C++标准库定义的名字在命名空间 `std`中。

`std`：标准库所使用的命名空间。`std::cout`表示我们要使用定义在命名空间 `std`中的名字 `cout`。

**字符串常量(string literal)**：零或多个字符组成的序列，用**双引号**包围。

**未初始化的变量(uninitialized variable)**：未赋予初值的变量。类类型的变量如果未指定初值，则按类指定的方式进行初始化。**定义在函数内部的内置类型变量默认是不初始化的，除非有显式的初始化语句。**试图使用一个未初始化的值是错误的。未初始化变量是bug的常见成因。

## 2.1 基本内置类型

C++定义了一套包括**算术类型**和**空类型**在内的基本数据类型。其中**算术类型包含了字符、整数型、布尔值和浮点数**。**空类型不对应具体的值，仅用于一些特殊的场合**。

### 2.1.1 算术类型

算数类型分为：整型（integral type，包括字符和布尔类型在内）和浮点型。

布尔类型（bool）的取值是真(true)或者假(false)。

基本的字符类型是 `char`，一个 `char`的空间应确保可以存放机器基本字符集中任意字符对应的数字值。也就是说，一个 `char`的大小和一个机器字节一样。

> C++语言规定：
>
> sizeof(short) ≤ sizeof(int)≤ sizeof(long)≤ sizeof(long long)

> **内置类型的机器实现**
>
> 计算机以比特序列存储数据，每个比特非0即1。
>
> 大多数计算机以2的整数次幂个比特作为块来处理内存，可寻址的最小内存块称为“字节(byte)”，存储的基本单元称为“字(word)”，通常由几个字节组成。
>
> 大多数计算机将内存中的每个字节与一个数字（被称为“地址(address)”）关联起来。
>
> 为了赋予内存中某个地址明确的含义，必须首先知道存储在该地址的数据的类型。类型决定了数据所占的比特数以及该如何解释这些比特的内容。

浮点型可表示单精度、双精度和扩展精度值。通常，`float`以1个字（32比特）来表示，`double`以2个字（64比特）来表示。一般来说，类型 `float`和 `double`分别有7和16个有效位。

**带符号类型和无符号类型**

除去布尔型和扩展的字符型之外，其他整型可以划分为**带符号**(signed)的和**无符号**(unsigned)的两种。带符号类型可以表示正数、负数和0，无符号类型则仅能表示大于等于0的值。类型 `unsigned int`可以缩写为 `unsigned`。

无符号类型中所有比特都用来存储值。

> - 执行浮点数运算选用 `double`，因为 `float`通常精度不够而且双精度浮点数和单精度浮点数的计算代价相差无几。

### 2.1.2 类型转换

当在程序的某处我们使用了一种类型而其实对象应该取另一种类型时，程序会自动进行类型转换(convert)。

```cpp
#include <iostream>

int main()
{
    // 把一个非布尔类型的算术值赋给布尔类型时，初始值为0则结果为false，否则结果为true
    bool b = 42;        // b为真(true)
    int i = b;          // i = 1
    // 把浮点数赋给整数类型时，进行了近似处理。结果值将仅保留浮点数中小数点之前的部分
    i = 3.14;           // i = 3
    // 把整数赋给浮点数时，小数部分记为0.
    double pi = i;      // pi = 3.0
    // 当赋给无符号类型一个超出它表示范围的值时，结果是
    // 初始值对无符号类型表示数值总数取模后的余数。256 - 1 = 255 
    unsigned char c = -1;   // c = 255
    // 当赋给带符号类型一个超过它表示范围的值时，结果是未定义的(undefined)
    signed char c2 = 256;   //假设char占8比特，c2值是未定义的

    return 0;
}
```

- 含有无符号类型的表达式

当一个表达式中既有无符号又有 `int`值时，那个 `int`值就会转换成无符号数。把 `int`转换成无符号数的过程和把 `int`直接赋给无符号变量一样：

```cpp
int main()
{
    // 含有无符号类型的表达式
    unsigned u = 10;
    i = -42;
    std::cout << i + i << std::endl; // -84
    std::cout << u + i << std::endl; // 2^32-42+10 = 42949672564

    unsigned u1 = 42, u2 = 10;
    std::cout << u1 - u2 << std::endl;  // 32
    std::cout << u2 - u1 << std::endl;  // -32 -> 2^32-32 = 42949672564

    //无符号数不会小于这一事实同样关系到循环的写法。
    for(int j=10; j>=0; --j)
        std::cout << i << std::endl;

    /* 错误：变量k永远也不会小于0，循环条件一直成立
     * for(unsigned k=10; k>=0; --k)
     *    std::cout << j << std::endl;
     */

    return 0;
}
```

> **切勿混用带符号类型和无符号类型**
>
> 如果表达式里既有带符号类型又有无符号类型，当带符号类型取值为负时会出现异常结果，这是因为**带符号数会自动地转换成无符号数**。

```cpp
int main()
{
    // 练习2.3
    unsigned u = 10, u2 = 42;
    std::cout << u2 - u << std::endl;   // 32
    std::cout << u - u2 << std::endl;   // 42949672564

    int i = 10, i2 = 42;
    std::cout << i2 - i << std::endl;   // 32
    std::cout << i - i2 << std::endl;   // -32
    std::cout << i - u << std::endl;    // 0
    std::cout << u - i << std::endl;    // 0

    return 0;
}
```

### 2.1.3字面值常量

一个形如42的值被称作**字面值常量(literal)**，这样的值一望而知。每个字面值常量都对应一种数据类型，字面值常量的形式和值决定了它的数据类型。

- 整型和浮点型字面值

可以将整型字面值写作十进制数、八进制数或十六进制数的形式。以0开头的整数代表八进制数，以 `0x`或 `0X`开头的代表十六进制数。

```markdown
20 /*十进制*/
024 /*八进制*/
0x4 /*十六进制*/
```

整数字面值具体的数据类型由它的值和符号决定。**默认情况下，十进制字面值是带符号数**，类型是 `int long long long`中尺寸最小的那个。如果一个字面值连与之关联的最大的数据类型都放不下，将产生错误。**类型 `short`没有对应的字面值**。

浮点数字面值表现为一个小数或科学计数法表示的指数，其中指数部分用 `E`或 `e`标识：`3.14159 3.14E-1 0. 0e0 .001`。**默认的，浮点型字面值是一个 `double`**。

- 字符和字符串字面值

**由单引号括起来的一个字符称为 `char`型字面值；双引号括起来的零个或多个字符则构成字符串型字面值。**

```markdown
'a'	//字符字面值
"Hello World!"	//字符串字面值
```

如果两个字符串字面值位置紧邻且仅由空格、缩进和换行符分割，则它们实际上是一个整体。当书写的字符串字面值比较长，写在一行不太合适时，就可以采取分开书写的方式：

```cpp
// 分多行书写的字符串字面值
std::cout << "a really, really long string literal "
             "that spans two lines" << std::endl;

```

- 转义序列

有两类字符程序员不能直接使用：

1. 不可打印(nonprintable)的字符，如退格或其他控制字符，因为它们没有可视的图符；
2. 在C++语言中有特殊含义的字符(单引号、双引号、问好、反斜线)。

在这些情况下需要用到转义序列(escape sequence)，转义序列均以反斜线作为开始，C++语言规定的转义序列包括：

| 换行符 | \n     | 横向制表符 | \t     | 报警符 | \a     |
| ------ | ------ | ---------- | ------ | ------ | ------ |
| 退格符 | `\b` | 双引号     | `\"` | 单引号 | `'`  |
| 反斜线 | `\\` | 问号       | `\?` | 回车符 | `\r` |

也可以使用**泛化的转义序列**，其形式是 `\x`后紧跟1个或多个十六进制数字，或者 `\`后跟1个、2个或3个八进制数字，其中**数字部分表示的是字符对应的数值**。

> 注意：如果反斜线 `\`后面跟着的八进制数字超过3个，只有前3个数字与 `\`构成转义序列。例如，`\1234`表示2个字符，即八进制数123对应的字符以及字符4.
>
> 相反，`\x`要用到后面跟着的所有数字，例如，`\x1234`表示一个16位的字符，该字符由4个十六进制数所对应的比特唯一确定。

- 指定字面值的类型

通过添加如下表所列的前缀和后缀，可以改变整型、浮点型和字符型字面值的默认类型。

| 前缀               | 含义                        | 类型           |
| ------------------ | --------------------------- | -------------- |
| 字符和字符串字面值 |                             |                |
| `u`              | Unicode 16字符              | char16_t       |
| `U`              | Unicode 32字符              | char32_t       |
| `L`              | 宽字符                      | wchar_t        |
| `u8`             | UTF-8(仅用于字符串字面常量) | **char** |
| 整型字面值-后缀    |                             |                |
| `u` or `U`     | unsigned                    |                |
| `l` or `L`     | long                        |                |
| `ll` or `LL`   | long long                   |                |
| 浮点型字面值-后缀  |                             |                |
| `f` or `F`     | float                       |                |
| `l` or `L`     | long double                 |                |

- 布尔字面值和指针字面值

`true`和 `false`是布尔类型的字面值；`nullptr`是指针字面值。

```cpp
#include <iostream>

int main()
{
    //分多行书写的字符串字面值
    std::cout << "a really, really long string literal "
                "that spans two lines" << std::endl;    // a really, really long string literal that spans two lines

    // 指定字面值的类型
    L'a';   //宽字符型字面值，类型是wchar_t
    u8"hi!";    // utf-8字符串字面值(utf-8用8位编码一个Unicode字符)，类型是 char
    42ULL;  // 无符号整型字面值，类型是 unsigned long long 
    1E-3F;  // 单精度浮点型字面值，类型是 float
    3.14159L;   //扩展精度浮点型字面值，类型是 long double

    // 布尔字面值和指针字面值
    bool test = false;
    nullptr;    //指针字面值

    // 练习2.6
    int month = 9, day = 7;
    // int m = 09, d = 07; //八进制，且09无效的八进制

    // 练习2.8
    std::cout << "2" << "\115\n" << std::endl;       // 先输出2M，然后转到新一行
    std::cout << "2" << "\t\115\n" << std::endl;
    return 0;
}
```

## 2.2 变量

变量提供一个具名的、可供程序操作的存储空间。C++中的每个变量都有其数据类型，数据类型决定着变量所占内存空间的大小和布局方式、该空间能存储的值的范围，以及该变量能参与的运算。对C++程序员来说，“变量(variable)”和“对象(object)”一般可以互换使用。

### 2.2.1 变量定义

变量定义的基本形式是：首先是类型说明符，随后紧跟由一个或多个变量名组成的列表，其中变量名以逗号分隔，最后以分号结束。

> 通常情况下，对象是指一块能存储数据并具有某种类型的内存空间。

- 初始值

当对象**在创建时获得了一个特定的值**，就说这个对象被初始化(initialized)了。当一次定义了两个或多个变量时，对象的名字随着定义也就马上可以使用了。因此在同一条定义语句中，可以用先定义的变量值去初始化后定义的其他变量。

```cpp
#include <iostream>
#include <string>

int main()
{
    int sum = 0, value,
        unit_sold = 0;
    std::string book("0-201-78345-X");  //book通过一个string字面值初始化

    double salary = 9999.99, wage = salary;

    return 0;
}
```

> 在C++语言中，初始化和赋值是两个完全不同的操作。
>
> **初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。**

- 列表初始化

C++语言定义了初始化的好几种不同形式。例如，像定义一个名为a的int型变量并初始化为0，以下的4调语句都可以做到这一点：

```cpp
int a = 0;
int a = {0};	//列表初始化
int a{0};	//列表初始化
int a(0);
```

用花括号(`{}`)来初始化变量的形式被称为**列表初始化**(list initialization)。

**当用于内置类型的变量时，这种初始化形式有一个重要特点：如果我们要使用列表初始化且初始值存在丢失信息的风险，则编译器将报错**：

```cpp
//使用列表初始化且初始值存在丢失信息的风险时，编译器将报错
long double ld = 3.1415926536;
int a{ld}, b = {ld};    //错误：转换未执行，因为存在丢失信息的危险
int c(ld), d = ld;  //正确：转换执行，且确实丢失了部分值
```

- 默认初始化

如果**定义变量时没有指定初值，则变量被默认初始化(default initialized)**，此时变量被赋予了默认值。默认值到底是什么由变量类型决定，同时定义变量的位置也会对此有影响。

1. 如果是**内置类型**的变量未被显式初始化，它的值由**定义的位置**决定。定义任何函数体之外的变量被初始化为0。**定义在函数体内部的内置类型变量将不被初始化。一个未被初始化的内置类型变量的值是未定义的**，如果试图拷贝或以其他形式访问此类值将引发错误。
2. **每个类各自决定了其初始化对象的方式**。而且，是否允许不经初始化就定义对象也由类自己决定。绝大多数类都支持无须显式初始化而定义对象，这样的类提供了一个合适的默认值。

> 未初始化的变量含有一个不确定的值，使用未初始化变量的值是一种错误的编程行为而且很难调试。
>
> 建议初始化每一个内置类型的变量。

### 2.2.2 变量声明和定义的关系

为了允许把程序拆分成多个逻辑部分来编写，C++语言支持**分离式编译**机制，该机制允许将程序分割为若干个文件，每个文件可被单独编译。

为了支持分离式编译，C++语言将声明和定义区分开来。声明(declaration)使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而定义(define)负责创建与名字关联的实体。

> 变量声明规定了变量的类型和名字，在这一点上定义与之相同。但是除此之外，定义还申请了存储空间，也可能会为变量赋一个初始值。

如果想声明一个变量而非定义它，就在变量名前添加关键字 `extern`，而且不要显式地初始化变量。任何包含了显式初始化的声明即成为定义。

```cpp
#include <iostream>
#include <string>

// 在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错
extern double pi = 3.1415926;   //定义

int main()
{
    //声明
    extern int i;   //声明i而非定义i
    int j;          //声明并定义j

    return 0;
}
```

> 变量能且只能被定义一次，但是可以被多次声明。

**变量的定义必须出现且只能出现在一个文件中，而其他用到该变量的文件必须对其进行声明，却绝对不能重复定义。**

### 2.2.3 标识符

C++的标识符(identifier)由字母、数字和下划线组成，其中必须以字母或下划线开头。标识符的长度没有限制，但是对大小写字母敏感。

C++语言保留了一些名字供语言本身使用，这些名字不能被用作标识符。同时，C++也为标准库保留了一些名字。用户自定义的标识符不能连续出现两个下划线，也不能以下划线紧跟大写字母开头。此外，定义在函数体外的标识符不能以下划线开头。

**变量命名规范**

- 标识符要能体现实际含义
- 变量名一般用小写字母。
- 用户自定义的类名一般以大写字母开头，例如Sales_item。
- 如果标识符由多个单词组成，则单词间应有明显区分。如student_loan。

| C++      | 关键字   | 在此不一一列举 |
| -------- | -------- | -------------- |
| continue | register | if             |
| true     | new      | this           |

### 2.2.4 名字的作用域

**作用域**(scope)是程序的一部分，在其中名字有其特定的含义。C++语言中大多数作用域都以**花括号**分隔。

同一个名字在不同的作用域中可能指向不同的实体。**名字的有效区域始于名字的声明语句，以声明语句所在的作用域末端为结束**。

```cpp
#include<iostream>

/*
 * 程序定义了3个名字：main、sum和val
 * 同时使用了命名空间名字std，该空间提供了2个名字cout和cin供程序使用。
 * main定义于所有花括号意之外，拥有全局作用域
 * sum拥有块作用域
 * val定义于for语句内，在for语句之内可以访问val，但是在main函数的其他部分就不能访问它了
*/
int main()
{
    int sum = 0;
    for(int val=1; val<=10; ++val){
        sum += val;
    }
    std::cout << "Sum pf i to 10 inclusive is "
                << sum << std::endl;

    return 0;
}
```

- 嵌套的作用域

作用域中一旦声明了某个名字，它所嵌套着的所有作用域中都能访问该名字。同时，允许在内层作用域中重新定义外层作用域已有的名字：

```cpp
#include <iostream>
//该程序仅用于说明：函数内部不宜定义与全局变量同名的新变量。
int reused = 42;    //reused拥有全局作用域
int main()
{
    int unique = 0; //块作用域
    std::cout << reused << " " << unique << std::endl;      // 42 0
    int reused = 0; //新建局部变量，覆盖了全局变量 reused
    std::cout << reused << " " << unique << std::endl;      // 0 0
    //显式地访问全局变量reused
    std::cout << ::reused << " " << unique << std::endl;    // 42 0

    return 0;
}
```

> 因为全局作用域本身没有名字，所以当作用域操作符的左侧为空时，想全局作用域发出请求获取作用域操作符右侧名字对应的变量。

## 2.3 复合类型

**符合类型(compoud type)**是指基于其他类型定义的类型。

一条声明语句由一个基本数据类型(base type)和紧随其后的一个声明符(declarator)列表组成。每个声明符命名了一个变量并指定该变量为与基本数据类型有关的某种类型。

### 2.3.1 引用

引用(reference)为对象起了另外一个别名，引用类型引用(refer to)另外一种类型。通过将声明符写成 `&d`的形式来定义引用类型，其中d是声明的变量名。

定义引用时，程序把引用和它的初始值绑定(bind)在一起，而不是将初始值拷贝给引用。**一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另一个对象，因此引用必须初始化**。

> 引用并非对象。相反的，它只是一个已经存在的对象所起的另外一个名字。
>
> 因为引用本身不是一个对象，所以不能定义引用的引用。

引用的类型要和与之绑定的对象严格匹配。而且，**引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起**。

```cpp
int main()
{
    int ival = 1024;
    int &refVal = ival;
    // int &refVal2;   // 报错：引用必须初始化！

    refVal = 2;
    int ii = refVal;    //与 ii = ival 执行结果一样

    //引用只能绑定在对象上，而不能与字面值或某个表达式的结果绑定在一起
    // int &refVal2 = 10;  //错误：引用类型的初始值必须是一个对象
    double dval = 3.14;
    // int &refVal3 = dval;    //错误：此处引用类型的初始值必须是int型对象

    return 0;
}
```

### 2.3.2 指针

指针(pointer)是“指向(point to)”另外一种类型的复合类型。与引用类似，指针也实现了对其他对象的间接访问。

> 指针和引用的主要区别：
>
> 1. 引用是另一个对象的别名。引用必须初始化，并且一旦定义了引用就无法再绑定到其他对象。
> 2. 指针本身就是一个对象。指针无须在定义时赋初值，也可以重新赋值让其指向其他对象。

定义指针类型的方法将声明符写成 `*d`的形式，其中d是变量名。

- 获取对象的地址

**指针存放某个对象的地址，要想获取该地址，需要使用取地址符(操作符 `&`)**。在声明语句中指针的类型实际上被用于指定它所指向对象的类型,所以二者必须匹配.

```cpp
int main()
{
    int ival = 42;
    int *p = &ival; //p存放变量ival的地址，或者说p是指向变量ival的指针

    //指针的类型要和它所指的对象严格匹配
    double dval;
    double *pd = &dval;
    double *pd2 = pd;

    // int *pi = pd;   //错误：类型不匹配
    // pi = &dval;     //错误：类型不匹配

    return 0;
}
```

**指针值**:指针的值(即地址)应属于下列4种状态之一:

1. 指向一个对象
2. 指向紧邻对象所占空间的下一个位置
3. 空指针,意味着指针没有指向任何对象.
4. 无效指针,也就是上述情况之外的其他值

- 利用指针访问对象

如果指针指向了一个对象,则允许使用解引用符 `*`来访问该对象.解引用仅适用于那些确实指向了某个对象的有效指针.

```cpp
int main()
{
    int ival = 42;
    int *p = &ival; //p存放变量ival的地址，或者说p是指向变量ival的指针

    //指针的类型要和它所指的对象严格匹配
    double dval;
    double *pd = &dval;
    double *pd2 = pd;

    // int *pi = pd;   //错误：类型不匹配
    // pi = &dval;     //错误：类型不匹配

    //利用指针访问对象
    std::cout << *p << std::endl;   // 42

    return 0;
}
```

- **空指针**

**空指针(null pointer)不指向任何对象**,在试图使用一个指针之前代码可以首先检查它是否为空.等到空指针最直接的办法就是用字面值 `nullptr`来初始化指针.

```cpp
//空指针
int *p1 = nullptr;  //nullptr空指针字面值
int *p2 = 0;        //与上等价
// 需要首先 #include <cstdlib>
int *p3 = NULL;     //等价于 int *p3 = 0;
//把int变量直接赋给指针是错误的操作,即使int变量的值恰好等于0也不行
int zero = 0;
// int *pi = zero;  //错误:不能把int变量直接赋给指针
```

> 过去的程序还会使用到一个名为 `NULL`的预处理变量来给指针赋值,这个变量在头文件 `cstdlib`中定义,它的值为0.
>
> 预处理器是在运行于编译过程之前的一段程序.预处理变量不属于命名空间std,它由预处理器负责管理,因此可以直接使用预处理变量而无须在前面加上 `std::`.
>
> 当用到一个预处理变量时,预处理器会自动地将它替换为实际值,因此 `NULL`初始化指针和用0初始化指针是一样的.

- 其他指针操作

如果指针的值是0,条件取false;任何非0指针对应的条件值都是true.

```cpp
//其他指针操作
int *pi = 0;
if(pi)
    std::cout << "pi的值为0,因此条件的值是false" << std::endl;

if(*pi)
    std::cout << "pi指向的值是0,因此条件是false" << std::endl;

//如果两个指针存放的地址值相同,则它们相等
//地址值相等由三种可能:都为空;都指向同一个对象;都指向了用一个对象的下一个地址

```

- void*指针

`void*`是一种特殊的指针类型,可用于存放任意对象的地址.但我们对该地址到底是个什么类型的对象并不了解.

```cpp
//void*指针
double obj = 3.14, *pd3 = &obj;
void *pv = &obj;    //obj可以是任意类型的对象
pv = pd3;
```

### 2.3.3 理解符合类型的声明

在同一条定义语句中,虽然基本数据类型只有一个,但是声明符的形式却可以不同.也就是说,一条定义语句可能定义出不同类型的变量:

```cpp
int i = 1024, *p = &i, &r = i;
```

- 指向指针的指针

一般来说,声明符中修饰符的个数并没有限制.通过 `*`的个数可以区分指针的级别.也就是说,`**`表示指向指针的指针,`***`表示指向指针的指针的指针.

```cpp
int ival = 1024;
int *pi = &ival;
int **ppi = & pi;	//指向一个int型的指针
```

- 指向指针的引用

引用本身不是一个对象,因此不能定义指向引用的指针.但指针是对象,所以存在对象指针的引用.

```cpp
int main()
{
    //指向指针的引用
    int i = 42;
    int *p;         //p是一个int型指针
    int *&r = p;    //r是指针p的引用
    r = &i;         //使p指向i
    *r = 0;         //使i值为0

    return 0;
}
```

> 要理解r的类型到底是什么,最简单的办法是从右小左阅读r的定义.离变量最近的符号(此例中是 `&r`中的 `&`)对变量的类型有最直接的影响,因此r是一个引用.声明符其余部分用以确定r引用的类型是什么,此例中的符号 `*`说明r引用的是一个指针.最后,声明的基本数据类型部分指出r引用的是一个int指针.

```cpp
//练习2.25
int *ip, ii, &r = ii;   // ip指针;ii整型;r引用
int iii, *iip = 0;      //iii整型;iip空指针
int* iiip, ip2;		// iiip指针;ip2整型
```
