## 3.5 数组

与 `vector`相似的地方是，数组也是存放类型相同的对象的容器，这些对象本身没有名字，需要通过其所在位置访问。与 `vector`不同的地方是，数**组的大小确定不变。不能随意向数组中增加元素**。

### 3.5.1 定义和初始化内置数组

数组是一种复合类型。数组的声明形如 `a[d]`，其中a数组的名字，d数组的维度。维度说明了数组中**元素的个数，因此必须大于0**。**数组中元素的个数也属于数组类型的一部分，编译时维度应该是已知，即维度必须是一个常量表达式**。数组的元素应是对象,因此不存在引用的数组.

```cpp
// 定义和初始化数组
unsigned cnt = 42;  // 不是常量表达式
constexpr unsigned sz = 42; // 常量表达式
int arr[10];
int *parr[sz];  // parr是一个包含42个元素的数组，每个元素都是指向int的指针
// string bad[cnt];    // 错误：cnt不是常量表达式
// string strs[get_size()];    // 当get_size是constexpr时正确;否则错误
```

**默认情况下,数组的元素被默认初始化**.

> WARNING:和内置类型的变量一样,如果在函数内部定义了某种内置类型的数组,那么默认初始化会令数组含有未定义的值.

**显式初始化数组元素**

可以对数组的元素进行列表初始化,此时允许忽略数组的维度.如果在声明时没有指明维度,编译器会根据初始值的数量计算并推测出来;相反,如果指明了维度,那么初始值的总数量不应该超出指定的大小.**如果维度比提供的初始值数量大,则用提供的初始值初始化靠前的元素,剩下的元素被初始化成默认值**.

```cpp
// 显式初始化数组元素
const unsigned n = 3;
int ia1[n] = {0, 1, 2}; // 含有3个元素的数组,元素值分别是0,1,2
int a2[] = {0, 1, 2};   // 维度是3的数组
int a3[5] = {0, 1, 2};  // 等价于 a3[] = {0,1,2,0,0}
string a4[3] = {"hi", "world"}; // 等价于 a4[] = {"hi", "world", ""}
// int a5[2] = {0, 1, 2};  // 错误:初始值过多
```

**字符数组的特殊性**

**字符数组**有一种额外的初始化形式,可以用**字符串字面值对此类数组初始化**.当使用这种方式时,一定要**注意字符串字面值的结尾处还有一个空字符,这个空字符也会像字符串的其他字符一样被拷贝到字符数组中**.

```cpp
// 字符数组的特殊性
char c1[] = {'C', '+', '+'};    // 列表初始化,没有空字符
char c2[] = {'C', '+', '+', '\0'};  // 列表初始化,含有显式的空字符
char c3[] = "C++";  // 自动添加表示字符串结束的空字符
// const char c4[6] = "Daniel";    // 错误:没有空间可存放空字符!
```

### **不允许拷贝和赋值**

**!!!不能将数组的内容拷贝给其他数组作为其初始值,也不能用数组为其他数组赋值!!!**.

```cpp
// 不允许拷贝和赋值
int a6[] = {0, 1, 2};
// int a7[] = a6;  // 错误:不允许使用一个数组初始化另外一个数组
// int a8[];       // 不允许使用不完整的类型,数组的大小也是其类型的一部分
// a7 = a6;    // 错误:不能把一个数组直接赋值给另外一个数组
```

**理解复杂的数组声明**

**默认情况下,类型修饰符从右向左依次绑定**.对于ptrs来说,从右向左理解其含义比较简单:首先知道定义的是一个大小为10的数组,它的名字是ptrs,然后知道数组中存放的是指向int的指针.由内向外的顺序可以更好地理解 `Parray`的含义:首先是圆括号括起来的部分,`*Parray`意味着Parray是个指针,接下来观察右边,可知道Parray是个指向大小为10的数组的指针,最后观察左边,知道数组中的元素是int.

```cpp
// 理解复杂的数组声明
int *ptrs[10];              // ptrs是一个含有10个元素数组,每个元素都是int*
// int &refs[10] = /* ? */;    // 错误:不存在引用的数组
int (*Parray)[10] = &arr;   // Parray是一个指针,指向一个含有10个int元素的数组 arr
int (&arrRef)[10] = arr;    // arrRef是一个引用,绑定到一个含有10个int元素的数组 arr
int *(&arry)[10] = ptrs;    // array是一个引用,绑定到一个int *[10],即含有10个int*的数组ptrs上
```

> 要想理解数组声明的含义,最好的办法是**从数组的名字开始按照由内向外的顺序阅读**.

### 3.5.2 访问数组元素

与标准库类型 `vector`和 `string`一样,数组的元素也能使用**范围 for 语句**或**下标运算符**来访问.数组的索引从0开始.

**在使用数组下标的时候,通常将其定义为 `size_t`类型.`size_t`是一种机器相关的无符号类型,它被设计得足够大以便能表示内存中任意对象的大小.在 `cstddef`头文件中定义了 `size_t`类型**,这个文件是C标准库 `stddef.h`头文件的C++语言版本.数组除了大小固定这一特点外,其他用法与vector基本类似.

```cpp
// 用数组来记录各分数段的成绩个数
unsigned scores[11] = {};    // 11各分数段,全部初始化为0
unsigned grade;
while(cin >> grade){
    if(grade <=100 )
        ++scores[grade/10]; // 将当前分数段的计数加1
}
for(auto s : scores){
    cout << s << " ";
}
cout << endl;
```

> 数组中所用的下标运算符是由C++语言直接定义的,这个运算符能用在数组类型的运算对象上.vector对象中所用的下标运算符是库模板vector定义的,只能用于vector类型的运算对象.

与vector和string一样,当需要遍历数组的所有元素时,最好的办法也是使用范围for语句.因为**维度是数组类型的一部分**,所以系统知道数组socres中有多少各元素,使用范围for语句可以减轻人为控制遍历过程的负担.

### 3.5.3 指针和数组

在C++语言中,指针和数组有非常紧密的联系.使用数组的时候编译器一般会把它转换成指针.通常情况下,使用取地址符 `&`来获取指向某个对象的指针,取地址符可以用于任何对象.对数组元素使用取地址符就能得到指向该元素的指针.

```cpp
string nums[] = {"one", "two", "three"};    // 数组的元素是string对象
string *p = &nums[0];   // p指向nums的第一个元素
string *p1 = nums;      // 与上等价,nums自动转换为首元素地址
```

**数组有个特性:在 很多 用到数组名的地方,编译器会自动地将其替换为一个指向数组首元素的指针**.在大多数表达式中,使用数组类型的对象其实是使用一个指向该数组元素的指针.在一些情况下数组的操作实际上是指针的操作.

```cpp
string nums[] = {"one", "two", "three"};    // 数组的元素是string对象
string *p = &nums[0];   // p指向nums的第一个元素
string *p1 = nums;      // 与上等价,nums自动转换为首元素地址

// 当使用数组作为一个auto变量的初始值时,推断得到的类型是指针而非数组
int ia[] = {0,1,2,3,4,5,6,7,8,9};
auto ia2(ia);   // 等价于 auto ia2(&ia[0]);  ia2是一个整型指针,指向ia的第一个元素
// ia2 = 42;   // 错误:不能用int值给指针赋值

// 当使用decltype关键字时,上述转换不会发生
decltype(ia) ia3 = {0,1,2,3,4,5,6,7,8,9};   // ia3是一个含有10个整数的数组
ia3[4] = 42;    // 把42赋值给ia3的一个元素

// 指针也是迭代器
int arr[] = {0,1,2,3,4,5,6,7,8,9};
int *p2 = arr;  // p2指向arr的第一个元素
++p2;           // p2指向arr[1]
```

**使用指针也能遍历数组中的元素**.这样做需要先得到指向数组得第一个元素和指向数组尾元素的下一个位置的指针.我们**可以设法获取数组尾元素之后那个并不存在的元素的位置**.其唯一的用处就是提供其地址用于初始化e(如下).不能对尾后指针执行解引用或递增操作:

```cpp
// 使用指针遍历数组中的元素
int *e = &arr[10];  // 指向arr尾元素的下一位置的指针
for(int *b=arr; b!=e; ++b)
    cout << *b << endl;	// 输出arr的元素
```

**标准库函数begin和end**

C++11新标准引用了两个名为 `begin`和 `end`的**函数**.这两个函数与容器中的两个同名成员函数功能类似,不过数组不是类类型,因此**这两个函数不是成员函数.正确的使用形式是将数组作为它们的参数:**

```cpp
// 使用指针遍历数组中的元素
int *e = &arr[10];  // 指向arr尾元素的下一位置的指针
for(int *b=arr; b!=e; ++b)
    cout << *b << endl; // 输出arr的元素

int a[] = {0,1,2,3,-4,5,6,7,8,9};
int *beg = begin(a), *last = end(a); // 指向a首元素和尾元素的下一位置的指针
// 寻找第一个负值元素,如果已检查完全部元素则结束循环,输出结果-4
while(beg != last){	// 通过比较beg和last,确保可以安全解引用beg
    if(*beg < 0){
        cout << *beg << endl;
        break;
    }
    ++beg;
}
```

**指针运算**

指向数组元素的指针可以执行诸如,解引用,递增,递减,比较,与整数相加,两个指针相减等.这些运算在指针和在迭代器上意义完全一致.给一个指针加上(减去)某个整数值,结果仍是指针.新指针指向的元素与原来的指针相比前进了(后退了)该整数个位置

```cpp
// 指针运算
constexpr size_t sz = 5;
int b[sz] = {0,1,2,3,4};
int *ip = b;    // 等价于 int *ip = &b[0]
int *ip2 = b+4; // ip2指向b的尾元素b[4]
int *ip3 = b+sz;    // 正确:ip3指向了b尾元素的下一位置,不要解引用
// int *ip4 = b+10;    // 错误:b只有5个元素,ip4的值未定义,编译器不会报错
auto d = end(d) - begin(d);	// d的值为5,即d中元素的数量
```

和迭代器一样,两个指针相减的结果是它们之间的距离.参与运算的指针必须指向同一个数组当中的元素.两个指针相减的结果类型是一种名为 `ptrdiff_t`的标准库类型,和 `size_t`一样也是定义在 `cstddef`头文件种的机器相关的类型.因为差值可能为负值,所以 `ptrdiff_t`是一种**带符号类型**.如果两个指针分别指向不相关的对象,则不能比较它们.

**下标和指针**

在很多情况下使用数组的名字其实用的是一个指向数组首元素的指针.一个典型的例子是当对数组使用下标运算符时,编译器会自动执行上述转换操作.

```cpp
// 下标和指针
int arr1[] = {0,2,4,6,8};
int x = arr1[2];    // arr1[2]使用了数组名的表达式,对数组执行下标运算其实是对指向数组元素的指针指向下标运算

int *ip5 = arr1;
x = *(ip5+2);   // 等价于 x = arr1[2]

int *ip6 = &arr1[2];    // ip6指向索引为2的元素
int y = ip6[1];         // ip6[1]等价于 *(ip6+1),就是ip6[3]表示的那个元素
int z = ip6[-2];        // ip6[-2]是arr1[0]表示的那个元素
```

**标准库类型限定使用的下标必须是无符号类型**,而内置的下标运算符无此要求,上面的最后一个例子很好地说明了这一点.**内置地下标运算符可以处理负值,结果地址必须指向原来的指针所指同一数组中的元素(或是同一数组尾元素的下一位置)**.

> 内置的下标运算符所用的索引值不是无符号类型,这一点与vector和string不一样.

```cpp
#include <iostream>
#include <string>
#include <vector>
using namespace std;

/*
* 分别输入两个数组的首地址和尾后地址,比较两个数组是否相等
*/
bool compare_array(int* const b1, int* const e1, int* const b2, int* const e2){
    if((e1-b1) != (e2-b2))
        return false;
    for(int *i=b1,*j=b2; (i!=e1) && (j!=e2); ++i,++j){
        if(*i != *j)
            return false;
    }
    return true;
}

int main()
{
    // 练习3.34
    constexpr unsigned sz = 7;
    int a[7] = {0,5,9,6,12,21,10};
    int *p1 = begin(a), *p2 = &a[4];
    p1 += p2 - p1;  // 将p1移动到p2位置,任何情况下都是合法的

    // 练习3.35:编写一段程序,利用指针将数组中的元素置为0
    int *beg = begin(a), *last = end(a);
    while(beg != last){
        *beg = 0;
        ++beg;
    }
    for(int i : a){
        cout << i << " ";
    }
    cout << endl;

    // 练习3.36:编写一段程序,比较两个数组是否相等
    int b[] = {0,5,9,6,12,21,10};
    int c[] = {0,5,9,6,12,21,10};
    int d[] = {1,9,4,9,2,0,2,3};
    if(compare_array(begin(b), end(b), begin(c), end(c)))
        cout << "The two arrays are equal!" << endl;
    else
        cout << "Not equal!" << endl;

    // 再写一段程序,比较两个vector对象是否相等
    // 判断vector对象是否相等,可以直接使用 == 

    return 0;
}
```

### 3.5.4 C风格字符串

字符串字面值是一种通用结构的实例，这种结构即是C++由C继承而来的**C风格字符串(C-style character string)**。C风格字符串不是一种类型，而是为了表达和使用字符串而形成的一种约定俗称的写法。按此习惯书写的字符串**存放在字符数组中中并以空字符结束**。以空字符结束的意思是在字符串最后一个字符后面跟着一个空字符 `\0`。

C标准库String函数

C语言标准库提供的一组函数，这些函数可用于操作C风格字符串，它们定义在 `cstring`头文件中，`cstring`是C语言头文件 `string.h`的C++版本。

| C风格字符串的函数  | 功能                                                                                             |
| ------------------ | ------------------------------------------------------------------------------------------------ |
| `strlen(p)`      | 返回p的长度，空字符不计算在内                                                                    |
| `strcmp(p1, p2)` | 比较p1和p2的相等性。如果 `p1==p2`，返回0；如果 `p1>p2`返回一个正；如果 `p1<p2`返回一个负值 |
| `strcat(p1, p2)` | 将p2附加到p1之后，返回p1                                                                         |
| `strcpy(p1, p2)` | 将p2拷贝给p去，返回p1                                                                            |

**传入此类函数的指针必须是指向以空字符为结束的数组**。

```cpp
// 传入C风格字符串的函数的指针必须是指向以空字符作为结束的数组
char ca[] = {'C', '+', '+'};
cout << strlen(ca) << endl; // 严重错误：ca没有以空字符结束，但是编译器不报错
```

**比较字符串**

比较两个C风格字符串的方法与之前学过的比较标准库string对象的方法大相径庭。比较标准库string对象的时候，用的是普通的关系运算符和相等性运算符。

```cpp
// 比较字符串
string s1 = "A string example";
string s2 = "A different string";
if(s1 < s2)  cout << "s1 < s2" << endl;
else        cout << "s1 > s2" << endl;  // s1 > s2

// 如果把上述比较运算符用在两个C风格字符串上，实际比较的将是指针而非字符本身
const char ca1[] = "A string example";
const char ca2[] = "A different string";
// 当使用数组的时候其实真正用的是指向数组首元素的指针
// if(ca1 < ca2)   // 未定义的：试图比较两个无关地址

// 使用 strcmp函数 比较两个C风格字符串，此时比较的就不再是指针
if(strcmp(ca1, ca2) < 0)    cout << "ca1 < ca2" << endl;
else    cout << "ca1 > ca2" << endl;
```

**目标字符串的大小由调用者指定**

使用 `strcat`函数和 `strcpy`函数拼接C风格字符串，必须提供一个用于存放结果字符串的数组，该数组必须足够大以便容纳下结果字符串及末尾的空字符。如果计算错了拼接后字符串的大小将引发严重错误。

```cpp
// 拼接字符串
string s3 = s1 + " " + s2;
cout << s3 << endl;     // A string example A different string

// 表达式 ca1+ca2试图将两个指针相加，显然这样的操作没什么意义，也肯定是非法的
char ca3[35];   // 16 + 18 + 1(空字符)
strcpy(ca3, ca1);   // 把ca1拷贝给ca3
strcat(ca3, " ");   // 在ca3末尾加上一个空格
strcat(ca3, ca2);   // 把ca2连接到ca3后面
// 输出拼接后的结果
for(auto c : ca3)
    cout << c;      // A string example A different string
cout << endl;
```

### 3.5.5 与旧代码的接口

```cpp
// 允许使用字符串字面值来初始化string对象
string s("Hello World");
// 任何出现字符串字面值的地方都可以用以空字符结束的字符数组来替代
const char ca4[] = "happy";
string s4 = ca4;    // happy 允许使用以空字符结束的字符数组来初始化string对象或为string对象赋值
cout << s4 << endl;
string s5 = s4 + ca4;
cout << s5 << endl; // happyhappy 在string对象的加法运算中允许使用以空字符结束的字符数组作为其中一个运算对象(不能两个都是)
// 反之不成立，不能用string对象直接初始化指向字符的指针
// char *str = s;  // 错误：不能用string对象初始化char *
const char *str = s.c_str();    // string专门提供了一个名为c_str的成员函数，实现该功能
```

`c_str`函数返回值是一个C风格字符串，即函数的返回结果是一个指针，该指针指向一个以空字符结束的字符数组，而这个数组所存的数据恰好与那个string对象一样。结果指针的类型是 `const char *`，从而保证不会改变字符数组的内容。我们无法保证 `c_str`函数返回的数组一直有效，如果后续的操作该变量s的值就可能让之前返回的数组失去效用。

**使用数组初始化vector对象**

```cpp
// 使用数组初始化vector对象
int int_arr[] = {1,9,4,9,2,0,2,3};
// 前闭后开区间
vector<int> ivec(begin(int_arr), end(int_arr)); // ivec有8个元素，分别是int_arr中对应元素的副本
vector<int> ivec2(int_arr+1, int_arr+4);    // ivec2中的元素分别是int_arr[1]到int_arr[3]，即9，4，9
```

> 建议：**尽量使用标准库类型而非数组**
>
> 指针常用于底层操作，因此容易引发一些与繁琐细节有关的错误。

```cpp
#include <iostream>
#include <cstring>
#include <string>
#include <vector>

using namespace std;

int main()
{
    // 练习3.37：下面程序的含义，程序的输出结果是什么
    /*
    * 程序含义是输出数组中的每个元素，直到遇到空字符
    * 但是ca结尾没有'\0'，扫面完数组后程序不能正常结束
    */
    const char ca[] = {'h', 'e', 'l', 'l', 'o'};
    const char *cp = ca;    // cp是指向ca首元素的指针
    while(*cp){     // 解引用得到ca中的元素，该元素非空(空字符)持续循环
        cout << *cp << endl;    // 输出该元素
        ++cp;       // 指针递增，指向下一个元素
    }

    // 练习3.38
    /*
    - 两个指针(指向同一个数组)相减可以表示两个指针(在同一个数组中)的距离
    - 指针加或减去一个整数，表示指针向后或向前移动到某个位置
    - 指针相加并没有逻辑上的意义，因此两个指针不能相加
    */

   // 练习3.39
    string s1 = "hello";
    string s2 = "beautiful";
    if(s1 > s2)  cout << "s1 > s2" << endl;
    else if(s1 < s2) cout << "s1 < s2" << endl;
    else     cout << "s1 == s2" << endl;
    // 比较C风格字符串用strcmp，此处略

    // 练习3.40
    const char ca1[] = "hello";
    const char ca2[] = "world";
    char ca3[100];
    strcpy(ca3, ca1);   // 把ca1拷贝给ca3
    strcat(ca3, " ");   // 在ca3末尾添加空格
    strcat(ca3, ca2);   // 将ca2拼接到ca3
    for(char c : ca3)
        cout << c;
    cout << endl;   // hello world

    // 练习3.41：编写一段程序，用整型数组初始化一个vector对象
    int arr[] = {2,0,0,8};
    vector<int> vi1(begin(arr), end(arr));
    // 练习3.42：将含有整数元素的vector对象拷贝给一个整型数组
    vector<int> vi2{1,2,3,4,5,6,7,8,9,10};
    int arr2[10];
    for(int i=0; i<vi2.size(); ++i){
        arr2[i] = vi2[i];
    }
    for(int x : arr2)
        cout << x << " ";
    cout << endl;
  
    return 0;
}
```
